/*! For license information please see 2.bundle.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{25:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the "License");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an "AS IS" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Extends an object\'s prototype by another\'s.\r\n *\r\n * @param type1 The Type to be extended.\r\n * @param type2 The Type to extend with.\r\n * @ignore\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction extend(type1, type2) {\r\n    for (const property in type2.prototype) {\r\n        type1.prototype[property] = type2.prototype[property];\r\n    }\r\n}\r\n/**\r\n * @ignore\r\n */\r\nclass OverlayViewSafe {\r\n    constructor() {\r\n        // MarkerClusterer implements google.maps.OverlayView interface. We use the\r\n        // extend function to extend MarkerClusterer with google.maps.OverlayView\r\n        // because it might not always be available when the code is defined so we\r\n        // look for it at the last possible moment. If it doesn\'t exist now then\r\n        // there is no point going ahead :)\r\n        extend(OverlayViewSafe, google.maps.OverlayView);\r\n    }\r\n}\n\n/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the "License");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an "AS IS" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n *\r\n * @hidden\r\n */\r\nfunction toCssText(styles) {\r\n    return Object.keys(styles)\r\n        .reduce((acc, key) => {\r\n        if (styles[key]) {\r\n            acc.push(key + ":" + styles[key]);\r\n        }\r\n        return acc;\r\n    }, [])\r\n        .join(";");\r\n}\r\n/**\r\n *\r\n * @hidden\r\n */\r\nfunction coercePixels(pixels) {\r\n    return pixels ? pixels + "px" : undefined;\r\n}\r\n/**\r\n * A cluster icon.\r\n */\r\nclass ClusterIcon extends OverlayViewSafe {\r\n    /**\r\n     * @param cluster_ The cluster with which the icon is to be associated.\r\n     * @param styles_ An array of {@link ClusterIconStyle} defining the cluster icons\r\n     *  to use for various cluster sizes.\r\n     */\r\n    constructor(cluster_, styles_) {\r\n        super();\r\n        this.cluster_ = cluster_;\r\n        this.styles_ = styles_;\r\n        this.center_ = null;\r\n        this.div_ = null;\r\n        this.sums_ = null;\r\n        this.visible_ = false;\r\n        this.style = null;\r\n        this.setMap(cluster_.getMap()); // Note: this causes onAdd to be called\r\n    }\r\n    /**\r\n     * Adds the icon to the DOM.\r\n     */\r\n    onAdd() {\r\n        let cMouseDownInCluster;\r\n        let cDraggingMapByCluster;\r\n        const mc = this.cluster_.getMarkerClusterer();\r\n        const [major, minor] = google.maps.version.split(".");\r\n        const gmVersion = parseInt(major, 10) * 100 + parseInt(minor, 10);\r\n        this.div_ = document.createElement("div");\r\n        if (this.visible_) {\r\n            this.show();\r\n        }\r\n        this.getPanes().overlayMouseTarget.appendChild(this.div_);\r\n        // Fix for Issue 157\r\n        this.boundsChangedListener_ = google.maps.event.addListener(this.getMap(), "bounds_changed", function () {\r\n            cDraggingMapByCluster = cMouseDownInCluster;\r\n        });\r\n        google.maps.event.addDomListener(this.div_, "mousedown", () => {\r\n            cMouseDownInCluster = true;\r\n            cDraggingMapByCluster = false;\r\n        });\r\n        // March 1, 2018: Fix for this 3.32 exp bug, https://issuetracker.google.com/issues/73571522\r\n        // But it doesn\'t work with earlier releases so do a version check.\r\n        if (gmVersion >= 332) {\r\n            // Ugly version-dependent code\r\n            google.maps.event.addDomListener(this.div_, "touchstart", e => {\r\n                e.stopPropagation();\r\n            });\r\n        }\r\n        google.maps.event.addDomListener(this.div_, "click", e => {\r\n            cMouseDownInCluster = false;\r\n            if (!cDraggingMapByCluster) {\r\n                /**\r\n                 * This event is fired when a cluster marker is clicked.\r\n                 * @name MarkerClusterer#click\r\n                 * @param {Cluster} c The cluster that was clicked.\r\n                 * @event\r\n                 */\r\n                google.maps.event.trigger(mc, "click", this.cluster_);\r\n                google.maps.event.trigger(mc, "clusterclick", this.cluster_); // deprecated name\r\n                // The default click handler follows. Disable it by setting\r\n                // the zoomOnClick property to false.\r\n                if (mc.getZoomOnClick()) {\r\n                    // Zoom into the cluster.\r\n                    const mz = mc.getMaxZoom();\r\n                    const theBounds = this.cluster_.getBounds();\r\n                    mc.getMap().fitBounds(theBounds);\r\n                    // There is a fix for Issue 170 here:\r\n                    setTimeout(function () {\r\n                        mc.getMap().fitBounds(theBounds);\r\n                        // Don\'t zoom beyond the max zoom level\r\n                        if (mz !== null && mc.getMap().getZoom() > mz) {\r\n                            mc.getMap().setZoom(mz + 1);\r\n                        }\r\n                    }, 100);\r\n                }\r\n                // Prevent event propagation to the map:\r\n                e.cancelBubble = true;\r\n                if (e.stopPropagation) {\r\n                    e.stopPropagation();\r\n                }\r\n            }\r\n        });\r\n        google.maps.event.addDomListener(this.div_, "mouseover", () => {\r\n            /**\r\n             * This event is fired when the mouse moves over a cluster marker.\r\n             * @name MarkerClusterer#mouseover\r\n             * @param {Cluster} c The cluster that the mouse moved over.\r\n             * @event\r\n             */\r\n            google.maps.event.trigger(mc, "mouseover", this.cluster_);\r\n        });\r\n        google.maps.event.addDomListener(this.div_, "mouseout", () => {\r\n            /**\r\n             * This event is fired when the mouse moves out of a cluster marker.\r\n             * @name MarkerClusterer#mouseout\r\n             * @param {Cluster} c The cluster that the mouse moved out of.\r\n             * @event\r\n             */\r\n            google.maps.event.trigger(mc, "mouseout", this.cluster_);\r\n        });\r\n    }\r\n    /**\r\n     * Removes the icon from the DOM.\r\n     */\r\n    onRemove() {\r\n        if (this.div_ && this.div_.parentNode) {\r\n            this.hide();\r\n            google.maps.event.removeListener(this.boundsChangedListener_);\r\n            google.maps.event.clearInstanceListeners(this.div_);\r\n            this.div_.parentNode.removeChild(this.div_);\r\n            this.div_ = null;\r\n        }\r\n    }\r\n    /**\r\n     * Draws the icon.\r\n     */\r\n    draw() {\r\n        if (this.visible_) {\r\n            const pos = this.getPosFromLatLng_(this.center_);\r\n            this.div_.style.top = pos.y + "px";\r\n            this.div_.style.left = pos.x + "px";\r\n        }\r\n    }\r\n    /**\r\n     * Hides the icon.\r\n     */\r\n    hide() {\r\n        if (this.div_) {\r\n            this.div_.style.display = "none";\r\n        }\r\n        this.visible_ = false;\r\n    }\r\n    /**\r\n     * Positions and shows the icon.\r\n     */\r\n    show() {\r\n        if (this.div_) {\r\n            this.div_.className = this.className_;\r\n            this.div_.style.cssText = this.createCss_(this.getPosFromLatLng_(this.center_));\r\n            this.div_.innerHTML =\r\n                (this.style.url ? this.getImageElementHtml() : "") +\r\n                    this.getLabelDivHtml();\r\n            if (typeof this.sums_.title === "undefined" || this.sums_.title === "") {\r\n                this.div_.title = this.cluster_.getMarkerClusterer().getTitle();\r\n            }\r\n            else {\r\n                this.div_.title = this.sums_.title;\r\n            }\r\n            this.div_.style.display = "";\r\n        }\r\n        this.visible_ = true;\r\n    }\r\n    getLabelDivHtml() {\r\n        const mc = this.cluster_.getMarkerClusterer();\r\n        const ariaLabel = mc.ariaLabelFn(this.sums_.text);\r\n        const divStyle = {\r\n            position: "absolute",\r\n            top: coercePixels(this.anchorText_[0]),\r\n            left: coercePixels(this.anchorText_[1]),\r\n            color: this.style.textColor,\r\n            "font-size": coercePixels(this.style.textSize),\r\n            "font-family": this.style.fontFamily,\r\n            "font-weight": this.style.fontWeight,\r\n            "font-style": this.style.fontStyle,\r\n            "text-decoration": this.style.textDecoration,\r\n            "text-align": "center",\r\n            width: coercePixels(this.style.width),\r\n            "line-height": coercePixels(this.style.textLineHeight)\r\n        };\r\n        return `\n<div aria-label="${ariaLabel}" style="${toCssText(divStyle)}" tabindex="0">\n  <span aria-hidden="true">${this.sums_.text}</span>\n</div>\n`;\r\n    }\r\n    getImageElementHtml() {\r\n        // NOTE: values must be specified in px units\r\n        const bp = (this.style.backgroundPosition || "0 0").split(" ");\r\n        const spriteH = parseInt(bp[0].replace(/^\\s+|\\s+$/g, ""), 10);\r\n        const spriteV = parseInt(bp[1].replace(/^\\s+|\\s+$/g, ""), 10);\r\n        let dimensions = {};\r\n        if (this.cluster_.getMarkerClusterer().getEnableRetinaIcons()) {\r\n            dimensions = {\r\n                width: coercePixels(this.style.width),\r\n                height: coercePixels(this.style.height)\r\n            };\r\n        }\r\n        else {\r\n            const [Y1, X1, Y2, X2] = [\r\n                -1 * spriteV,\r\n                -1 * spriteH + this.style.width,\r\n                -1 * spriteV + this.style.height,\r\n                -1 * spriteH\r\n            ];\r\n            dimensions = {\r\n                clip: `rect(${Y1}px, ${X1}px, ${Y2}px, ${X2}px)`\r\n            };\r\n        }\r\n        const cssText = toCssText(Object.assign({ position: "absolute", top: coercePixels(spriteV), left: coercePixels(spriteH) }, dimensions));\r\n        return `<img alt="${this.sums_.text}" aria-hidden="true" src="${this.style.url}" style="${cssText}"/>`;\r\n    }\r\n    /**\r\n     * Sets the icon styles to the appropriate element in the styles array.\r\n     *\r\n     * @ignore\r\n     * @param sums The icon label text and styles index.\r\n     */\r\n    useStyle(sums) {\r\n        this.sums_ = sums;\r\n        let index = Math.max(0, sums.index - 1);\r\n        index = Math.min(this.styles_.length - 1, index);\r\n        this.style = this.styles_[index];\r\n        this.anchorText_ = this.style.anchorText || [0, 0];\r\n        this.anchorIcon_ = this.style.anchorIcon || [\r\n            Math.floor(this.style.height / 2),\r\n            Math.floor(this.style.width / 2)\r\n        ];\r\n        this.className_ =\r\n            this.cluster_.getMarkerClusterer().getClusterClass() +\r\n                " " +\r\n                (this.style.className || "cluster-" + index);\r\n    }\r\n    /**\r\n     * Sets the position at which to center the icon.\r\n     *\r\n     * @param center The latlng to set as the center.\r\n     */\r\n    setCenter(center) {\r\n        this.center_ = center;\r\n    }\r\n    /**\r\n     * Creates the `cssText` style parameter based on the position of the icon.\r\n     *\r\n     * @param pos The position of the icon.\r\n     * @return The CSS style text.\r\n     */\r\n    createCss_(pos) {\r\n        return toCssText({\r\n            "z-index": `${this.cluster_.getMarkerClusterer().getZIndex()}`,\r\n            top: coercePixels(pos.y),\r\n            left: coercePixels(pos.x),\r\n            width: coercePixels(this.style.width),\r\n            height: coercePixels(this.style.height),\r\n            cursor: "pointer",\r\n            position: "absolute",\r\n            "-webkit-user-select": "none",\r\n            "-khtml-user-select": "none",\r\n            "-moz-user-select": "none",\r\n            "-o-user-select": "none",\r\n            "user-select": "none"\r\n        });\r\n    }\r\n    /**\r\n     * Returns the position at which to place the DIV depending on the latlng.\r\n     *\r\n     * @param latlng The position in latlng.\r\n     * @return The position in pixels.\r\n     */\r\n    getPosFromLatLng_(latlng) {\r\n        const pos = this.getProjection().fromLatLngToDivPixel(latlng);\r\n        pos.x = Math.floor(pos.x - this.anchorIcon_[1]);\r\n        pos.y = Math.floor(pos.y - this.anchorIcon_[0]);\r\n        return pos;\r\n    }\r\n}\n\n/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the "License");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an "AS IS" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Creates a single cluster that manages a group of proximate markers.\r\n *  Used internally, do not call this constructor directly.\r\n */\r\nclass Cluster {\r\n    /**\r\n     *\r\n     * @param markerClusterer_ The `MarkerClusterer` object with which this\r\n     *  cluster is associated.\r\n     */\r\n    constructor(markerClusterer_) {\r\n        this.markerClusterer_ = markerClusterer_;\r\n        this.map_ = this.markerClusterer_.getMap();\r\n        this.minClusterSize_ = this.markerClusterer_.getMinimumClusterSize();\r\n        this.averageCenter_ = this.markerClusterer_.getAverageCenter();\r\n        this.markers_ = []; // TODO: type;\r\n        this.center_ = null;\r\n        this.bounds_ = null;\r\n        this.clusterIcon_ = new ClusterIcon(this, this.markerClusterer_.getStyles());\r\n    }\r\n    /**\r\n     * Returns the number of markers managed by the cluster. You can call this from\r\n     * a `click`, `mouseover`, or `mouseout` event handler for the `MarkerClusterer` object.\r\n     *\r\n     * @return The number of markers in the cluster.\r\n     */\r\n    getSize() {\r\n        return this.markers_.length;\r\n    }\r\n    /**\r\n     * Returns the array of markers managed by the cluster. You can call this from\r\n     * a `click`, `mouseover`, or `mouseout` event handler for the `MarkerClusterer` object.\r\n     *\r\n     * @return The array of markers in the cluster.\r\n     */\r\n    getMarkers() {\r\n        return this.markers_;\r\n    }\r\n    /**\r\n     * Returns the center of the cluster. You can call this from\r\n     * a `click`, `mouseover`, or `mouseout` event handler\r\n     * for the `MarkerClusterer` object.\r\n     *\r\n     * @return The center of the cluster.\r\n     */\r\n    getCenter() {\r\n        return this.center_;\r\n    }\r\n    /**\r\n     * Returns the map with which the cluster is associated.\r\n     *\r\n     * @return The map.\r\n     * @ignore\r\n     */\r\n    getMap() {\r\n        return this.map_;\r\n    }\r\n    /**\r\n     * Returns the `MarkerClusterer` object with which the cluster is associated.\r\n     *\r\n     * @return The associated marker clusterer.\r\n     * @ignore\r\n     */\r\n    getMarkerClusterer() {\r\n        return this.markerClusterer_;\r\n    }\r\n    /**\r\n     * Returns the bounds of the cluster.\r\n     *\r\n     * @return the cluster bounds.\r\n     * @ignore\r\n     */\r\n    getBounds() {\r\n        const bounds = new google.maps.LatLngBounds(this.center_, this.center_);\r\n        const markers = this.getMarkers();\r\n        for (let i = 0; i < markers.length; i++) {\r\n            bounds.extend(markers[i].getPosition());\r\n        }\r\n        return bounds;\r\n    }\r\n    /**\r\n     * Removes the cluster from the map.\r\n     *\r\n     * @ignore\r\n     */\r\n    remove() {\r\n        this.clusterIcon_.setMap(null);\r\n        this.markers_ = [];\r\n        delete this.markers_;\r\n    }\r\n    /**\r\n     * Adds a marker to the cluster.\r\n     *\r\n     * @param marker The marker to be added.\r\n     * @return True if the marker was added.\r\n     * @ignore\r\n     */\r\n    addMarker(marker) {\r\n        if (this.isMarkerAlreadyAdded_(marker)) {\r\n            return false;\r\n        }\r\n        if (!this.center_) {\r\n            this.center_ = marker.getPosition();\r\n            this.calculateBounds_();\r\n        }\r\n        else {\r\n            if (this.averageCenter_) {\r\n                const l = this.markers_.length + 1;\r\n                const lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;\r\n                const lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;\r\n                this.center_ = new google.maps.LatLng(lat, lng);\r\n                this.calculateBounds_();\r\n            }\r\n        }\r\n        marker.isAdded = true;\r\n        this.markers_.push(marker);\r\n        const mCount = this.markers_.length;\r\n        const mz = this.markerClusterer_.getMaxZoom();\r\n        if (mz !== null && this.map_.getZoom() > mz) {\r\n            // Zoomed in past max zoom, so show the marker.\r\n            if (marker.getMap() !== this.map_) {\r\n                marker.setMap(this.map_);\r\n            }\r\n        }\r\n        else if (mCount < this.minClusterSize_) {\r\n            // Min cluster size not reached so show the marker.\r\n            if (marker.getMap() !== this.map_) {\r\n                marker.setMap(this.map_);\r\n            }\r\n        }\r\n        else if (mCount === this.minClusterSize_) {\r\n            // Hide the markers that were showing.\r\n            for (let i = 0; i < mCount; i++) {\r\n                this.markers_[i].setMap(null);\r\n            }\r\n        }\r\n        else {\r\n            marker.setMap(null);\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Determines if a marker lies within the cluster\'s bounds.\r\n     *\r\n     * @param marker The marker to check.\r\n     * @return True if the marker lies in the bounds.\r\n     * @ignore\r\n     */\r\n    isMarkerInClusterBounds(marker) {\r\n        return this.bounds_.contains(marker.getPosition());\r\n    }\r\n    /**\r\n     * Calculates the extended bounds of the cluster with the grid.\r\n     */\r\n    calculateBounds_() {\r\n        const bounds = new google.maps.LatLngBounds(this.center_, this.center_);\r\n        this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\r\n    }\r\n    /**\r\n     * Updates the cluster icon.\r\n     */\r\n    updateIcon() {\r\n        const mCount = this.markers_.length;\r\n        const mz = this.markerClusterer_.getMaxZoom();\r\n        if (mz !== null && this.map_.getZoom() > mz) {\r\n            this.clusterIcon_.hide();\r\n            return;\r\n        }\r\n        if (mCount < this.minClusterSize_) {\r\n            // Min cluster size not yet reached.\r\n            this.clusterIcon_.hide();\r\n            return;\r\n        }\r\n        const numStyles = this.markerClusterer_.getStyles().length;\r\n        const sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\r\n        this.clusterIcon_.setCenter(this.center_);\r\n        this.clusterIcon_.useStyle(sums);\r\n        this.clusterIcon_.show();\r\n    }\r\n    /**\r\n     * Determines if a marker has already been added to the cluster.\r\n     *\r\n     * @param marker The marker to check.\r\n     * @return True if the marker has already been added.\r\n     */\r\n    isMarkerAlreadyAdded_(marker) {\r\n        if (this.markers_.indexOf) {\r\n            return this.markers_.indexOf(marker) !== -1;\r\n        }\r\n        else {\r\n            for (let i = 0; i < this.markers_.length; i++) {\r\n                if (marker === this.markers_[i]) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\n\n/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the "License");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an "AS IS" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @ignore\r\n */\r\nconst getOption = (options, prop, def) => {\r\n    if (options[prop] !== undefined) {\r\n        return options[prop];\r\n    }\r\n    else {\r\n        return def;\r\n    }\r\n};\r\nclass MarkerClusterer extends OverlayViewSafe {\r\n    /**\r\n     * Creates a MarkerClusterer object with the options specified in {@link MarkerClustererOptions}.\r\n     * @param map The Google map to attach to.\r\n     * @param markers The markers to be added to the cluster.\r\n     * @param options The optional parameters.\r\n     */\r\n    constructor(map, markers = [], options = {}) {\r\n        super();\r\n        this.options = options;\r\n        this.markers_ = [];\r\n        this.clusters_ = [];\r\n        this.listeners_ = [];\r\n        this.activeMap_ = null;\r\n        this.ready_ = false;\r\n        this.ariaLabelFn = this.options.ariaLabelFn || (() => "");\r\n        this.zIndex_ = this.options.zIndex || google.maps.Marker.MAX_ZINDEX + 1;\r\n        this.gridSize_ = this.options.gridSize || 60;\r\n        this.minClusterSize_ = this.options.minimumClusterSize || 2;\r\n        this.maxZoom_ = this.options.maxZoom || null;\r\n        this.styles_ = this.options.styles || [];\r\n        this.title_ = this.options.title || "";\r\n        this.zoomOnClick_ = getOption(this.options, "zoomOnClick", true);\r\n        this.averageCenter_ = getOption(this.options, "averageCenter", false);\r\n        this.ignoreHidden_ = getOption(this.options, "ignoreHidden", false);\r\n        this.enableRetinaIcons_ = getOption(this.options, "enableRetinaIcons", false);\r\n        this.imagePath_ = this.options.imagePath || MarkerClusterer.IMAGE_PATH;\r\n        this.imageExtension_ = this.options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;\r\n        this.imageSizes_ = this.options.imageSizes || MarkerClusterer.IMAGE_SIZES;\r\n        this.calculator_ = this.options.calculator || MarkerClusterer.CALCULATOR;\r\n        this.batchSize_ = this.options.batchSize || MarkerClusterer.BATCH_SIZE;\r\n        this.batchSizeIE_ = this.options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;\r\n        this.clusterClass_ = this.options.clusterClass || "cluster";\r\n        if (navigator.userAgent.toLowerCase().indexOf("msie") !== -1) {\r\n            // Try to avoid IE timeout when processing a huge number of markers:\r\n            this.batchSize_ = this.batchSizeIE_;\r\n        }\r\n        this.setupStyles_();\r\n        this.addMarkers(markers, true);\r\n        this.setMap(map); // Note: this causes onAdd to be called\r\n    }\r\n    /**\r\n     * Implementation of the onAdd interface method.\r\n     * @ignore\r\n     */\r\n    onAdd() {\r\n        this.activeMap_ = this.getMap();\r\n        this.ready_ = true;\r\n        this.repaint();\r\n        this.prevZoom_ = this.getMap().getZoom();\r\n        // Add the map event listeners\r\n        this.listeners_ = [\r\n            google.maps.event.addListener(this.getMap(), "zoom_changed", () => {\r\n                const map = this.getMap(); // eslint-disable-line @typescript-eslint/no-explicit-any\r\n                // Fix for bug #407\r\n                // Determines map type and prevents illegal zoom levels\r\n                const minZoom = map.minZoom || 0;\r\n                const maxZoom = Math.min(map.maxZoom || 100, map.mapTypes[map.getMapTypeId()].maxZoom);\r\n                const zoom = Math.min(Math.max(this.getMap().getZoom(), minZoom), maxZoom);\r\n                if (this.prevZoom_ != zoom) {\r\n                    this.prevZoom_ = zoom;\r\n                    this.resetViewport_(false);\r\n                }\r\n            }),\r\n            google.maps.event.addListener(this.getMap(), "idle", () => {\r\n                this.redraw_();\r\n            })\r\n        ];\r\n    }\r\n    /**\r\n     * Implementation of the onRemove interface method.\r\n     * Removes map event listeners and all cluster icons from the DOM.\r\n     * All managed markers are also put back on the map.\r\n     * @ignore\r\n     */\r\n    onRemove() {\r\n        // Put all the managed markers back on the map:\r\n        for (let i = 0; i < this.markers_.length; i++) {\r\n            if (this.markers_[i].getMap() !== this.activeMap_) {\r\n                this.markers_[i].setMap(this.activeMap_);\r\n            }\r\n        }\r\n        // Remove all clusters:\r\n        for (let i = 0; i < this.clusters_.length; i++) {\r\n            this.clusters_[i].remove();\r\n        }\r\n        this.clusters_ = [];\r\n        // Remove map event listeners:\r\n        for (let i = 0; i < this.listeners_.length; i++) {\r\n            google.maps.event.removeListener(this.listeners_[i]);\r\n        }\r\n        this.listeners_ = [];\r\n        this.activeMap_ = null;\r\n        this.ready_ = false;\r\n    }\r\n    /**\r\n     * Implementation of the draw interface method.\r\n     * @ignore\r\n     */\r\n    draw() { }\r\n    /**\r\n     * Sets up the styles object.\r\n     */\r\n    setupStyles_() {\r\n        if (this.styles_.length > 0) {\r\n            return;\r\n        }\r\n        for (let i = 0; i < this.imageSizes_.length; i++) {\r\n            const size = this.imageSizes_[i];\r\n            this.styles_.push(MarkerClusterer.withDefaultStyle({\r\n                url: this.imagePath_ + (i + 1) + "." + this.imageExtension_,\r\n                height: size,\r\n                width: size\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     *  Fits the map to the bounds of the markers managed by the clusterer.\r\n     */\r\n    fitMapToMarkers() {\r\n        const markers = this.getMarkers();\r\n        const bounds = new google.maps.LatLngBounds();\r\n        for (let i = 0; i < markers.length; i++) {\r\n            // March 3, 2018: Bug fix -- honor the ignoreHidden property\r\n            if (markers[i].getVisible() || !this.getIgnoreHidden()) {\r\n                bounds.extend(markers[i].getPosition());\r\n            }\r\n        }\r\n        this.getMap().fitBounds(bounds);\r\n    }\r\n    /**\r\n     * Returns the value of the `gridSize` property.\r\n     *\r\n     * @return The grid size.\r\n     */\r\n    getGridSize() {\r\n        return this.gridSize_;\r\n    }\r\n    /**\r\n     * Sets the value of the `gridSize` property.\r\n     *\r\n     * @param gridSize The grid size.\r\n     */\r\n    setGridSize(gridSize) {\r\n        this.gridSize_ = gridSize;\r\n    }\r\n    /**\r\n     * Returns the value of the `minimumClusterSize` property.\r\n     *\r\n     * @return The minimum cluster size.\r\n     */\r\n    getMinimumClusterSize() {\r\n        return this.minClusterSize_;\r\n    }\r\n    /**\r\n     * Sets the value of the `minimumClusterSize` property.\r\n     *\r\n     * @param minimumClusterSize The minimum cluster size.\r\n     */\r\n    setMinimumClusterSize(minimumClusterSize) {\r\n        this.minClusterSize_ = minimumClusterSize;\r\n    }\r\n    /**\r\n     *  Returns the value of the `maxZoom` property.\r\n     *\r\n     *  @return The maximum zoom level.\r\n     */\r\n    getMaxZoom() {\r\n        return this.maxZoom_;\r\n    }\r\n    /**\r\n     *  Sets the value of the `maxZoom` property.\r\n     *\r\n     *  @param maxZoom The maximum zoom level.\r\n     */\r\n    setMaxZoom(maxZoom) {\r\n        this.maxZoom_ = maxZoom;\r\n    }\r\n    getZIndex() {\r\n        return this.zIndex_;\r\n    }\r\n    setZIndex(zIndex) {\r\n        this.zIndex_ = zIndex;\r\n    }\r\n    /**\r\n     *  Returns the value of the `styles` property.\r\n     *\r\n     *  @return The array of styles defining the cluster markers to be used.\r\n     */\r\n    getStyles() {\r\n        return this.styles_;\r\n    }\r\n    /**\r\n     *  Sets the value of the `styles` property.\r\n     *\r\n     *  @param styles The array of styles to use.\r\n     */\r\n    setStyles(styles) {\r\n        this.styles_ = styles;\r\n    }\r\n    /**\r\n     * Returns the value of the `title` property.\r\n     *\r\n     * @return The content of the title text.\r\n     */\r\n    getTitle() {\r\n        return this.title_;\r\n    }\r\n    /**\r\n     *  Sets the value of the `title` property.\r\n     *\r\n     *  @param title The value of the title property.\r\n     */\r\n    setTitle(title) {\r\n        this.title_ = title;\r\n    }\r\n    /**\r\n     * Returns the value of the `zoomOnClick` property.\r\n     *\r\n     * @return True if zoomOnClick property is set.\r\n     */\r\n    getZoomOnClick() {\r\n        return this.zoomOnClick_;\r\n    }\r\n    /**\r\n     *  Sets the value of the `zoomOnClick` property.\r\n     *\r\n     *  @param zoomOnClick The value of the zoomOnClick property.\r\n     */\r\n    setZoomOnClick(zoomOnClick) {\r\n        this.zoomOnClick_ = zoomOnClick;\r\n    }\r\n    /**\r\n     * Returns the value of the `averageCenter` property.\r\n     *\r\n     * @return True if averageCenter property is set.\r\n     */\r\n    getAverageCenter() {\r\n        return this.averageCenter_;\r\n    }\r\n    /**\r\n     *  Sets the value of the `averageCenter` property.\r\n     *\r\n     *  @param averageCenter The value of the averageCenter property.\r\n     */\r\n    setAverageCenter(averageCenter) {\r\n        this.averageCenter_ = averageCenter;\r\n    }\r\n    /**\r\n     * Returns the value of the `ignoreHidden` property.\r\n     *\r\n     * @return True if ignoreHidden property is set.\r\n     */\r\n    getIgnoreHidden() {\r\n        return this.ignoreHidden_;\r\n    }\r\n    /**\r\n     *  Sets the value of the `ignoreHidden` property.\r\n     *\r\n     *  @param ignoreHidden The value of the ignoreHidden property.\r\n     */\r\n    setIgnoreHidden(ignoreHidden) {\r\n        this.ignoreHidden_ = ignoreHidden;\r\n    }\r\n    /**\r\n     * Returns the value of the `enableRetinaIcons` property.\r\n     *\r\n     * @return True if enableRetinaIcons property is set.\r\n     */\r\n    getEnableRetinaIcons() {\r\n        return this.enableRetinaIcons_;\r\n    }\r\n    /**\r\n     *  Sets the value of the `enableRetinaIcons` property.\r\n     *\r\n     *  @param enableRetinaIcons The value of the enableRetinaIcons property.\r\n     */\r\n    setEnableRetinaIcons(enableRetinaIcons) {\r\n        this.enableRetinaIcons_ = enableRetinaIcons;\r\n    }\r\n    /**\r\n     * Returns the value of the `imageExtension` property.\r\n     *\r\n     * @return The value of the imageExtension property.\r\n     */\r\n    getImageExtension() {\r\n        return this.imageExtension_;\r\n    }\r\n    /**\r\n     *  Sets the value of the `imageExtension` property.\r\n     *\r\n     *  @param imageExtension The value of the imageExtension property.\r\n     */\r\n    setImageExtension(imageExtension) {\r\n        this.imageExtension_ = imageExtension;\r\n    }\r\n    /**\r\n     * Returns the value of the `imagePath` property.\r\n     *\r\n     * @return The value of the imagePath property.\r\n     */\r\n    getImagePath() {\r\n        return this.imagePath_;\r\n    }\r\n    /**\r\n     *  Sets the value of the `imagePath` property.\r\n     *\r\n     *  @param imagePath The value of the imagePath property.\r\n     */\r\n    setImagePath(imagePath) {\r\n        this.imagePath_ = imagePath;\r\n    }\r\n    /**\r\n     * Returns the value of the `imageSizes` property.\r\n     *\r\n     * @return The value of the imageSizes property.\r\n     */\r\n    getImageSizes() {\r\n        return this.imageSizes_;\r\n    }\r\n    /**\r\n     *  Sets the value of the `imageSizes` property.\r\n     *\r\n     *  @param imageSizes The value of the imageSizes property.\r\n     */\r\n    setImageSizes(imageSizes) {\r\n        this.imageSizes_ = imageSizes;\r\n    }\r\n    /**\r\n     * Returns the value of the `calculator` property.\r\n     *\r\n     * @return the value of the calculator property.\r\n     */\r\n    getCalculator() {\r\n        return this.calculator_;\r\n    }\r\n    /**\r\n     * Sets the value of the `calculator` property.\r\n     *\r\n     * @param calculator The value of the calculator property.\r\n     */\r\n    setCalculator(calculator) {\r\n        this.calculator_ = calculator;\r\n    }\r\n    /**\r\n     * Returns the value of the `batchSizeIE` property.\r\n     *\r\n     * @return the value of the batchSizeIE property.\r\n     */\r\n    getBatchSizeIE() {\r\n        return this.batchSizeIE_;\r\n    }\r\n    /**\r\n     * Sets the value of the `batchSizeIE` property.\r\n     *\r\n     *  @param batchSizeIE The value of the batchSizeIE property.\r\n     */\r\n    setBatchSizeIE(batchSizeIE) {\r\n        this.batchSizeIE_ = batchSizeIE;\r\n    }\r\n    /**\r\n     * Returns the value of the `clusterClass` property.\r\n     *\r\n     * @return the value of the clusterClass property.\r\n     */\r\n    getClusterClass() {\r\n        return this.clusterClass_;\r\n    }\r\n    /**\r\n     * Sets the value of the `clusterClass` property.\r\n     *\r\n     *  @param clusterClass The value of the clusterClass property.\r\n     */\r\n    setClusterClass(clusterClass) {\r\n        this.clusterClass_ = clusterClass;\r\n    }\r\n    /**\r\n     *  Returns the array of markers managed by the clusterer.\r\n     *\r\n     *  @return The array of markers managed by the clusterer.\r\n     */\r\n    getMarkers() {\r\n        return this.markers_;\r\n    }\r\n    /**\r\n     *  Returns the number of markers managed by the clusterer.\r\n     *\r\n     *  @return The number of markers.\r\n     */\r\n    getTotalMarkers() {\r\n        return this.markers_.length;\r\n    }\r\n    /**\r\n     * Returns the current array of clusters formed by the clusterer.\r\n     *\r\n     * @return The array of clusters formed by the clusterer.\r\n     */\r\n    getClusters() {\r\n        return this.clusters_;\r\n    }\r\n    /**\r\n     * Returns the number of clusters formed by the clusterer.\r\n     *\r\n     * @return The number of clusters formed by the clusterer.\r\n     */\r\n    getTotalClusters() {\r\n        return this.clusters_.length;\r\n    }\r\n    /**\r\n     * Adds a marker to the clusterer. The clusters are redrawn unless\r\n     *  `nodraw` is set to `true`.\r\n     *\r\n     * @param marker The marker to add.\r\n     * @param nodraw Set to `true` to prevent redrawing.\r\n     */\r\n    addMarker(marker, nodraw) {\r\n        this.pushMarkerTo_(marker);\r\n        if (!nodraw) {\r\n            this.redraw_();\r\n        }\r\n    }\r\n    /**\r\n     * Adds an array of markers to the clusterer. The clusters are redrawn unless\r\n     *  `nodraw` is set to `true`.\r\n     *\r\n     * @param markers The markers to add.\r\n     * @param nodraw Set to `true` to prevent redrawing.\r\n     */\r\n    addMarkers(markers, nodraw) {\r\n        for (const key in markers) {\r\n            if (Object.prototype.hasOwnProperty.call(markers, key)) {\r\n                this.pushMarkerTo_(markers[key]);\r\n            }\r\n        }\r\n        if (!nodraw) {\r\n            this.redraw_();\r\n        }\r\n    }\r\n    /**\r\n     * Pushes a marker to the clusterer.\r\n     *\r\n     * @param marker The marker to add.\r\n     */\r\n    pushMarkerTo_(marker) {\r\n        // If the marker is draggable add a listener so we can update the clusters on the dragend:\r\n        if (marker.getDraggable()) {\r\n            google.maps.event.addListener(marker, "dragend", () => {\r\n                if (this.ready_) {\r\n                    marker.isAdded = false;\r\n                    this.repaint();\r\n                }\r\n            });\r\n        }\r\n        marker.isAdded = false;\r\n        this.markers_.push(marker);\r\n    }\r\n    /**\r\n     * Removes a marker from the cluster.  The clusters are redrawn unless\r\n     *  `nodraw` is set to `true`. Returns `true` if the\r\n     *  marker was removed from the clusterer.\r\n     *\r\n     * @param marker The marker to remove.\r\n     * @param nodraw Set to `true` to prevent redrawing.\r\n     * @return True if the marker was removed from the clusterer.\r\n     */\r\n    removeMarker(marker, nodraw) {\r\n        const removed = this.removeMarker_(marker);\r\n        if (!nodraw && removed) {\r\n            this.repaint();\r\n        }\r\n        return removed;\r\n    }\r\n    /**\r\n     * Removes an array of markers from the cluster. The clusters are redrawn unless\r\n     *  `nodraw` is set to `true`. Returns `true` if markers were removed from the clusterer.\r\n     *\r\n     * @param markers The markers to remove.\r\n     * @param nodraw Set to `true` to prevent redrawing.\r\n     * @return True if markers were removed from the clusterer.\r\n     */\r\n    removeMarkers(markers, nodraw) {\r\n        let removed = false;\r\n        for (let i = 0; i < markers.length; i++) {\r\n            const r = this.removeMarker_(markers[i]);\r\n            removed = removed || r;\r\n        }\r\n        if (!nodraw && removed) {\r\n            this.repaint();\r\n        }\r\n        return removed;\r\n    }\r\n    /**\r\n     * Removes a marker and returns true if removed, false if not.\r\n     *\r\n     * @param marker The marker to remove\r\n     * @return Whether the marker was removed or not\r\n     */\r\n    removeMarker_(marker) {\r\n        let index = -1;\r\n        if (this.markers_.indexOf) {\r\n            index = this.markers_.indexOf(marker);\r\n        }\r\n        else {\r\n            for (let i = 0; i < this.markers_.length; i++) {\r\n                if (marker === this.markers_[i]) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (index === -1) {\r\n            // Marker is not in our list of markers, so do nothing:\r\n            return false;\r\n        }\r\n        marker.setMap(null);\r\n        this.markers_.splice(index, 1); // Remove the marker from the list of managed markers\r\n        return true;\r\n    }\r\n    /**\r\n     * Removes all clusters and markers from the map and also removes all markers\r\n     *  managed by the clusterer.\r\n     */\r\n    clearMarkers() {\r\n        this.resetViewport_(true);\r\n        this.markers_ = [];\r\n    }\r\n    /**\r\n     * Recalculates and redraws all the marker clusters from scratch.\r\n     *  Call this after changing any properties.\r\n     */\r\n    repaint() {\r\n        const oldClusters = this.clusters_.slice();\r\n        this.clusters_ = [];\r\n        this.resetViewport_(false);\r\n        this.redraw_();\r\n        // Remove the old clusters.\r\n        // Do it in a timeout to prevent blinking effect.\r\n        setTimeout(function () {\r\n            for (let i = 0; i < oldClusters.length; i++) {\r\n                oldClusters[i].remove();\r\n            }\r\n        }, 0);\r\n    }\r\n    /**\r\n     * Returns the current bounds extended by the grid size.\r\n     *\r\n     * @param bounds The bounds to extend.\r\n     * @return The extended bounds.\r\n     * @ignore\r\n     */\r\n    getExtendedBounds(bounds) {\r\n        const projection = this.getProjection();\r\n        // Turn the bounds into latlng.\r\n        const tr = new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng());\r\n        const bl = new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng());\r\n        // Convert the points to pixels and the extend out by the grid size.\r\n        const trPix = projection.fromLatLngToDivPixel(tr);\r\n        trPix.x += this.gridSize_;\r\n        trPix.y -= this.gridSize_;\r\n        const blPix = projection.fromLatLngToDivPixel(bl);\r\n        blPix.x -= this.gridSize_;\r\n        blPix.y += this.gridSize_;\r\n        // Convert the pixel points back to LatLng\r\n        const ne = projection.fromDivPixelToLatLng(trPix);\r\n        const sw = projection.fromDivPixelToLatLng(blPix);\r\n        // Extend the bounds to contain the new bounds.\r\n        bounds.extend(ne);\r\n        bounds.extend(sw);\r\n        return bounds;\r\n    }\r\n    /**\r\n     * Redraws all the clusters.\r\n     */\r\n    redraw_() {\r\n        this.createClusters_(0);\r\n    }\r\n    /**\r\n     * Removes all clusters from the map. The markers are also removed from the map\r\n     *  if `hide` is set to `true`.\r\n     *\r\n     * @param hide Set to `true` to also remove the markers from the map.\r\n     */\r\n    resetViewport_(hide) {\r\n        // Remove all the clusters\r\n        for (let i = 0; i < this.clusters_.length; i++) {\r\n            this.clusters_[i].remove();\r\n        }\r\n        this.clusters_ = [];\r\n        // Reset the markers to not be added and to be removed from the map.\r\n        for (let i = 0; i < this.markers_.length; i++) {\r\n            const marker = this.markers_[i];\r\n            marker.isAdded = false;\r\n            if (hide) {\r\n                marker.setMap(null);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Calculates the distance between two latlng locations in km.\r\n     *\r\n     * @param p1 The first lat lng point.\r\n     * @param p2 The second lat lng point.\r\n     * @return The distance between the two points in km.\r\n     * @link http://www.movable-type.co.uk/scripts/latlong.html\r\n     */\r\n    distanceBetweenPoints_(p1, p2) {\r\n        const R = 6371; // Radius of the Earth in km\r\n        const dLat = ((p2.lat() - p1.lat()) * Math.PI) / 180;\r\n        const dLon = ((p2.lng() - p1.lng()) * Math.PI) / 180;\r\n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n            Math.cos((p1.lat() * Math.PI) / 180) *\r\n                Math.cos((p2.lat() * Math.PI) / 180) *\r\n                Math.sin(dLon / 2) *\r\n                Math.sin(dLon / 2);\r\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n        return R * c;\r\n    }\r\n    /**\r\n     * Determines if a marker is contained in a bounds.\r\n     *\r\n     * @param marker The marker to check.\r\n     * @param bounds The bounds to check against.\r\n     * @return True if the marker is in the bounds.\r\n     */\r\n    isMarkerInBounds_(marker, bounds) {\r\n        return bounds.contains(marker.getPosition());\r\n    }\r\n    /**\r\n     * Adds a marker to a cluster, or creates a new cluster.\r\n     *\r\n     * @param marker The marker to add.\r\n     */\r\n    addToClosestCluster_(marker) {\r\n        let distance = 40000; // Some large number\r\n        let clusterToAddTo = null;\r\n        for (let i = 0; i < this.clusters_.length; i++) {\r\n            const cluster = this.clusters_[i];\r\n            const center = cluster.getCenter();\r\n            if (center) {\r\n                const d = this.distanceBetweenPoints_(center, marker.getPosition());\r\n                if (d < distance) {\r\n                    distance = d;\r\n                    clusterToAddTo = cluster;\r\n                }\r\n            }\r\n        }\r\n        if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\r\n            clusterToAddTo.addMarker(marker);\r\n        }\r\n        else {\r\n            const cluster = new Cluster(this);\r\n            cluster.addMarker(marker);\r\n            this.clusters_.push(cluster);\r\n        }\r\n    }\r\n    /**\r\n     * Creates the clusters. This is done in batches to avoid timeout errors\r\n     *  in some browsers when there is a huge number of markers.\r\n     *\r\n     * @param iFirst The index of the first marker in the batch of\r\n     *  markers to be added to clusters.\r\n     */\r\n    createClusters_(iFirst) {\r\n        if (!this.ready_) {\r\n            return;\r\n        }\r\n        // Cancel previous batch processing if we\'re working on the first batch:\r\n        if (iFirst === 0) {\r\n            google.maps.event.trigger(this, "clusteringbegin", this);\r\n            if (typeof this.timerRefStatic !== "undefined") {\r\n                clearTimeout(this.timerRefStatic);\r\n                delete this.timerRefStatic;\r\n            }\r\n        }\r\n        // Get our current map view bounds.\r\n        // Create a new bounds object so we don\'t affect the map.\r\n        //\r\n        // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:\r\n        let mapBounds;\r\n        if (this.getMap().getZoom() > 3) {\r\n            mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast());\r\n        }\r\n        else {\r\n            mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));\r\n        }\r\n        const bounds = this.getExtendedBounds(mapBounds);\r\n        const iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);\r\n        for (let i = iFirst; i < iLast; i++) {\r\n            const marker = this.markers_[i];\r\n            if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\r\n                if (!this.ignoreHidden_ ||\r\n                    (this.ignoreHidden_ && marker.getVisible())) {\r\n                    this.addToClosestCluster_(marker);\r\n                }\r\n            }\r\n        }\r\n        if (iLast < this.markers_.length) {\r\n            this.timerRefStatic = window.setTimeout(() => {\r\n                this.createClusters_(iLast);\r\n            }, 0);\r\n        }\r\n        else {\r\n            delete this.timerRefStatic;\r\n            google.maps.event.trigger(this, "clusteringend", this);\r\n            for (let i = 0; i < this.clusters_.length; i++) {\r\n                this.clusters_[i].updateIcon();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * The default function for determining the label text and style\r\n     * for a cluster icon.\r\n     *\r\n     * @param markers The array of markers represented by the cluster.\r\n     * @param numStyles The number of marker styles available.\r\n     * @return The information resource for the cluster.\r\n     */\r\n    static CALCULATOR(markers, numStyles) {\r\n        let index = 0;\r\n        const count = markers.length;\r\n        let dv = count;\r\n        while (dv !== 0) {\r\n            dv = Math.floor(dv / 10);\r\n            index++;\r\n        }\r\n        index = Math.min(index, numStyles);\r\n        return {\r\n            text: count.toString(),\r\n            index: index,\r\n            title: ""\r\n        };\r\n    }\r\n    /**\r\n     * Generates default styles augmented with user passed values.\r\n     * Useful when you want to override some default values but keep untouched\r\n     *\r\n     * @param overrides override default values\r\n     */\r\n    static withDefaultStyle(overrides) {\r\n        return Object.assign({ textColor: "black", textSize: 11, textDecoration: "none", textLineHeight: overrides.height, fontWeight: "bold", fontStyle: "normal", fontFamily: "Arial,sans-serif", backgroundPosition: "0 0" }, overrides);\r\n    }\r\n}\r\n/**\r\n * The number of markers to process in one batch.\r\n */\r\nMarkerClusterer.BATCH_SIZE = 2000;\r\n/**\r\n * The number of markers to process in one batch (IE only).\r\n */\r\nMarkerClusterer.BATCH_SIZE_IE = 500;\r\n/**\r\n * The default root name for the marker cluster images.\r\n */\r\nMarkerClusterer.IMAGE_PATH = "../images/m";\r\n/**\r\n * The default extension name for the marker cluster images.\r\n */\r\nMarkerClusterer.IMAGE_EXTENSION = "png";\r\n/**\r\n * The default array of sizes for the marker cluster images.\r\n */\r\nMarkerClusterer.IMAGE_SIZES = [53, 56, 66, 78, 90];\n\n/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the "License");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an "AS IS" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/* unused harmony default export */ var _unused_webpack_default_export = (MarkerClusterer);\n//# sourceMappingURL=markerclustererplus.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tYXJrZXJjbHVzdGVyZXJwbHVzL2Rpc3QvbWFya2VyY2x1c3RlcmVycGx1cy5lc20uanM/MzQwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEV4dGVuZHMgYW4gb2JqZWN0J3MgcHJvdG90eXBlIGJ5IGFub3RoZXIncy5cclxuICpcclxuICogQHBhcmFtIHR5cGUxIFRoZSBUeXBlIHRvIGJlIGV4dGVuZGVkLlxyXG4gKiBAcGFyYW0gdHlwZTIgVGhlIFR5cGUgdG8gZXh0ZW5kIHdpdGguXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbmZ1bmN0aW9uIGV4dGVuZCh0eXBlMSwgdHlwZTIpIHtcclxuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gdHlwZTIucHJvdG90eXBlKSB7XHJcbiAgICAgICAgdHlwZTEucHJvdG90eXBlW3Byb3BlcnR5XSA9IHR5cGUyLnByb3RvdHlwZVtwcm9wZXJ0eV07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNsYXNzIE92ZXJsYXlWaWV3U2FmZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyBNYXJrZXJDbHVzdGVyZXIgaW1wbGVtZW50cyBnb29nbGUubWFwcy5PdmVybGF5VmlldyBpbnRlcmZhY2UuIFdlIHVzZSB0aGVcclxuICAgICAgICAvLyBleHRlbmQgZnVuY3Rpb24gdG8gZXh0ZW5kIE1hcmtlckNsdXN0ZXJlciB3aXRoIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3XHJcbiAgICAgICAgLy8gYmVjYXVzZSBpdCBtaWdodCBub3QgYWx3YXlzIGJlIGF2YWlsYWJsZSB3aGVuIHRoZSBjb2RlIGlzIGRlZmluZWQgc28gd2VcclxuICAgICAgICAvLyBsb29rIGZvciBpdCBhdCB0aGUgbGFzdCBwb3NzaWJsZSBtb21lbnQuIElmIGl0IGRvZXNuJ3QgZXhpc3Qgbm93IHRoZW5cclxuICAgICAgICAvLyB0aGVyZSBpcyBubyBwb2ludCBnb2luZyBhaGVhZCA6KVxyXG4gICAgICAgIGV4dGVuZChPdmVybGF5Vmlld1NhZmUsIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqXHJcbiAqIEBoaWRkZW5cclxuICovXHJcbmZ1bmN0aW9uIHRvQ3NzVGV4dChzdHlsZXMpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZXMpXHJcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcclxuICAgICAgICBpZiAoc3R5bGVzW2tleV0pIHtcclxuICAgICAgICAgICAgYWNjLnB1c2goa2V5ICsgXCI6XCIgKyBzdHlsZXNba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCBbXSlcclxuICAgICAgICAuam9pbihcIjtcIik7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBoaWRkZW5cclxuICovXHJcbmZ1bmN0aW9uIGNvZXJjZVBpeGVscyhwaXhlbHMpIHtcclxuICAgIHJldHVybiBwaXhlbHMgPyBwaXhlbHMgKyBcInB4XCIgOiB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqIEEgY2x1c3RlciBpY29uLlxyXG4gKi9cclxuY2xhc3MgQ2x1c3Rlckljb24gZXh0ZW5kcyBPdmVybGF5Vmlld1NhZmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY2x1c3Rlcl8gVGhlIGNsdXN0ZXIgd2l0aCB3aGljaCB0aGUgaWNvbiBpcyB0byBiZSBhc3NvY2lhdGVkLlxyXG4gICAgICogQHBhcmFtIHN0eWxlc18gQW4gYXJyYXkgb2Yge0BsaW5rIENsdXN0ZXJJY29uU3R5bGV9IGRlZmluaW5nIHRoZSBjbHVzdGVyIGljb25zXHJcbiAgICAgKiAgdG8gdXNlIGZvciB2YXJpb3VzIGNsdXN0ZXIgc2l6ZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNsdXN0ZXJfLCBzdHlsZXNfKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNsdXN0ZXJfID0gY2x1c3Rlcl87XHJcbiAgICAgICAgdGhpcy5zdHlsZXNfID0gc3R5bGVzXztcclxuICAgICAgICB0aGlzLmNlbnRlcl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGl2XyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdW1zXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3R5bGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2V0TWFwKGNsdXN0ZXJfLmdldE1hcCgpKTsgLy8gTm90ZTogdGhpcyBjYXVzZXMgb25BZGQgdG8gYmUgY2FsbGVkXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGljb24gdG8gdGhlIERPTS5cclxuICAgICAqL1xyXG4gICAgb25BZGQoKSB7XHJcbiAgICAgICAgbGV0IGNNb3VzZURvd25JbkNsdXN0ZXI7XHJcbiAgICAgICAgbGV0IGNEcmFnZ2luZ01hcEJ5Q2x1c3RlcjtcclxuICAgICAgICBjb25zdCBtYyA9IHRoaXMuY2x1c3Rlcl8uZ2V0TWFya2VyQ2x1c3RlcmVyKCk7XHJcbiAgICAgICAgY29uc3QgW21ham9yLCBtaW5vcl0gPSBnb29nbGUubWFwcy52ZXJzaW9uLnNwbGl0KFwiLlwiKTtcclxuICAgICAgICBjb25zdCBnbVZlcnNpb24gPSBwYXJzZUludChtYWpvciwgMTApICogMTAwICsgcGFyc2VJbnQobWlub3IsIDEwKTtcclxuICAgICAgICB0aGlzLmRpdl8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIGlmICh0aGlzLnZpc2libGVfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdldFBhbmVzKCkub3ZlcmxheU1vdXNlVGFyZ2V0LmFwcGVuZENoaWxkKHRoaXMuZGl2Xyk7XHJcbiAgICAgICAgLy8gRml4IGZvciBJc3N1ZSAxNTdcclxuICAgICAgICB0aGlzLmJvdW5kc0NoYW5nZWRMaXN0ZW5lcl8gPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcih0aGlzLmdldE1hcCgpLCBcImJvdW5kc19jaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY0RyYWdnaW5nTWFwQnlDbHVzdGVyID0gY01vdXNlRG93bkluQ2x1c3RlcjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGREb21MaXN0ZW5lcih0aGlzLmRpdl8sIFwibW91c2Vkb3duXCIsICgpID0+IHtcclxuICAgICAgICAgICAgY01vdXNlRG93bkluQ2x1c3RlciA9IHRydWU7XHJcbiAgICAgICAgICAgIGNEcmFnZ2luZ01hcEJ5Q2x1c3RlciA9IGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIE1hcmNoIDEsIDIwMTg6IEZpeCBmb3IgdGhpcyAzLjMyIGV4cCBidWcsIGh0dHBzOi8vaXNzdWV0cmFja2VyLmdvb2dsZS5jb20vaXNzdWVzLzczNTcxNTIyXHJcbiAgICAgICAgLy8gQnV0IGl0IGRvZXNuJ3Qgd29yayB3aXRoIGVhcmxpZXIgcmVsZWFzZXMgc28gZG8gYSB2ZXJzaW9uIGNoZWNrLlxyXG4gICAgICAgIGlmIChnbVZlcnNpb24gPj0gMzMyKSB7XHJcbiAgICAgICAgICAgIC8vIFVnbHkgdmVyc2lvbi1kZXBlbmRlbnQgY29kZVxyXG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGREb21MaXN0ZW5lcih0aGlzLmRpdl8sIFwidG91Y2hzdGFydFwiLCBlID0+IHtcclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGREb21MaXN0ZW5lcih0aGlzLmRpdl8sIFwiY2xpY2tcIiwgZSA9PiB7XHJcbiAgICAgICAgICAgIGNNb3VzZURvd25JbkNsdXN0ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCFjRHJhZ2dpbmdNYXBCeUNsdXN0ZXIpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGEgY2x1c3RlciBtYXJrZXIgaXMgY2xpY2tlZC5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIE1hcmtlckNsdXN0ZXJlciNjbGlja1xyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtDbHVzdGVyfSBjIFRoZSBjbHVzdGVyIHRoYXQgd2FzIGNsaWNrZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXZlbnRcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihtYywgXCJjbGlja1wiLCB0aGlzLmNsdXN0ZXJfKTtcclxuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIobWMsIFwiY2x1c3RlcmNsaWNrXCIsIHRoaXMuY2x1c3Rlcl8pOyAvLyBkZXByZWNhdGVkIG5hbWVcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGNsaWNrIGhhbmRsZXIgZm9sbG93cy4gRGlzYWJsZSBpdCBieSBzZXR0aW5nXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgem9vbU9uQ2xpY2sgcHJvcGVydHkgdG8gZmFsc2UuXHJcbiAgICAgICAgICAgICAgICBpZiAobWMuZ2V0Wm9vbU9uQ2xpY2soKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFpvb20gaW50byB0aGUgY2x1c3Rlci5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBteiA9IG1jLmdldE1heFpvb20oKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGVCb3VuZHMgPSB0aGlzLmNsdXN0ZXJfLmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1jLmdldE1hcCgpLmZpdEJvdW5kcyh0aGVCb3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgZml4IGZvciBJc3N1ZSAxNzAgaGVyZTpcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWMuZ2V0TWFwKCkuZml0Qm91bmRzKHRoZUJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHpvb20gYmV5b25kIHRoZSBtYXggem9vbSBsZXZlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXogIT09IG51bGwgJiYgbWMuZ2V0TWFwKCkuZ2V0Wm9vbSgpID4gbXopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1jLmdldE1hcCgpLnNldFpvb20obXogKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGV2ZW50IHByb3BhZ2F0aW9uIHRvIHRoZSBtYXA6XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkRG9tTGlzdGVuZXIodGhpcy5kaXZfLCBcIm1vdXNlb3ZlclwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIG1vdXNlIG1vdmVzIG92ZXIgYSBjbHVzdGVyIG1hcmtlci5cclxuICAgICAgICAgICAgICogQG5hbWUgTWFya2VyQ2x1c3RlcmVyI21vdXNlb3ZlclxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NsdXN0ZXJ9IGMgVGhlIGNsdXN0ZXIgdGhhdCB0aGUgbW91c2UgbW92ZWQgb3Zlci5cclxuICAgICAgICAgICAgICogQGV2ZW50XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKG1jLCBcIm1vdXNlb3ZlclwiLCB0aGlzLmNsdXN0ZXJfKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGREb21MaXN0ZW5lcih0aGlzLmRpdl8sIFwibW91c2VvdXRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBvdXQgb2YgYSBjbHVzdGVyIG1hcmtlci5cclxuICAgICAgICAgICAgICogQG5hbWUgTWFya2VyQ2x1c3RlcmVyI21vdXNlb3V0XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q2x1c3Rlcn0gYyBUaGUgY2x1c3RlciB0aGF0IHRoZSBtb3VzZSBtb3ZlZCBvdXQgb2YuXHJcbiAgICAgICAgICAgICAqIEBldmVudFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihtYywgXCJtb3VzZW91dFwiLCB0aGlzLmNsdXN0ZXJfKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgaWNvbiBmcm9tIHRoZSBET00uXHJcbiAgICAgKi9cclxuICAgIG9uUmVtb3ZlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRpdl8gJiYgdGhpcy5kaXZfLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuYm91bmRzQ2hhbmdlZExpc3RlbmVyXyk7XHJcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmNsZWFySW5zdGFuY2VMaXN0ZW5lcnModGhpcy5kaXZfKTtcclxuICAgICAgICAgICAgdGhpcy5kaXZfLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kaXZfKTtcclxuICAgICAgICAgICAgdGhpcy5kaXZfID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBpY29uLlxyXG4gICAgICovXHJcbiAgICBkcmF3KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZpc2libGVfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zRnJvbUxhdExuZ18odGhpcy5jZW50ZXJfKTtcclxuICAgICAgICAgICAgdGhpcy5kaXZfLnN0eWxlLnRvcCA9IHBvcy55ICsgXCJweFwiO1xyXG4gICAgICAgICAgICB0aGlzLmRpdl8uc3R5bGUubGVmdCA9IHBvcy54ICsgXCJweFwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGlkZXMgdGhlIGljb24uXHJcbiAgICAgKi9cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGl2Xykge1xyXG4gICAgICAgICAgICB0aGlzLmRpdl8uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpc2libGVfID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBvc2l0aW9ucyBhbmQgc2hvd3MgdGhlIGljb24uXHJcbiAgICAgKi9cclxuICAgIHNob3coKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGl2Xykge1xyXG4gICAgICAgICAgICB0aGlzLmRpdl8uY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWVfO1xyXG4gICAgICAgICAgICB0aGlzLmRpdl8uc3R5bGUuY3NzVGV4dCA9IHRoaXMuY3JlYXRlQ3NzXyh0aGlzLmdldFBvc0Zyb21MYXRMbmdfKHRoaXMuY2VudGVyXykpO1xyXG4gICAgICAgICAgICB0aGlzLmRpdl8uaW5uZXJIVE1MID1cclxuICAgICAgICAgICAgICAgICh0aGlzLnN0eWxlLnVybCA/IHRoaXMuZ2V0SW1hZ2VFbGVtZW50SHRtbCgpIDogXCJcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGFiZWxEaXZIdG1sKCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdW1zXy50aXRsZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0aGlzLnN1bXNfLnRpdGxlID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpdl8udGl0bGUgPSB0aGlzLmNsdXN0ZXJfLmdldE1hcmtlckNsdXN0ZXJlcigpLmdldFRpdGxlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpdl8udGl0bGUgPSB0aGlzLnN1bXNfLnRpdGxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGl2Xy5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aXNpYmxlXyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXRMYWJlbERpdkh0bWwoKSB7XHJcbiAgICAgICAgY29uc3QgbWMgPSB0aGlzLmNsdXN0ZXJfLmdldE1hcmtlckNsdXN0ZXJlcigpO1xyXG4gICAgICAgIGNvbnN0IGFyaWFMYWJlbCA9IG1jLmFyaWFMYWJlbEZuKHRoaXMuc3Vtc18udGV4dCk7XHJcbiAgICAgICAgY29uc3QgZGl2U3R5bGUgPSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgIHRvcDogY29lcmNlUGl4ZWxzKHRoaXMuYW5jaG9yVGV4dF9bMF0pLFxyXG4gICAgICAgICAgICBsZWZ0OiBjb2VyY2VQaXhlbHModGhpcy5hbmNob3JUZXh0X1sxXSksXHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLnN0eWxlLnRleHRDb2xvcixcclxuICAgICAgICAgICAgXCJmb250LXNpemVcIjogY29lcmNlUGl4ZWxzKHRoaXMuc3R5bGUudGV4dFNpemUpLFxyXG4gICAgICAgICAgICBcImZvbnQtZmFtaWx5XCI6IHRoaXMuc3R5bGUuZm9udEZhbWlseSxcclxuICAgICAgICAgICAgXCJmb250LXdlaWdodFwiOiB0aGlzLnN0eWxlLmZvbnRXZWlnaHQsXHJcbiAgICAgICAgICAgIFwiZm9udC1zdHlsZVwiOiB0aGlzLnN0eWxlLmZvbnRTdHlsZSxcclxuICAgICAgICAgICAgXCJ0ZXh0LWRlY29yYXRpb25cIjogdGhpcy5zdHlsZS50ZXh0RGVjb3JhdGlvbixcclxuICAgICAgICAgICAgXCJ0ZXh0LWFsaWduXCI6IFwiY2VudGVyXCIsXHJcbiAgICAgICAgICAgIHdpZHRoOiBjb2VyY2VQaXhlbHModGhpcy5zdHlsZS53aWR0aCksXHJcbiAgICAgICAgICAgIFwibGluZS1oZWlnaHRcIjogY29lcmNlUGl4ZWxzKHRoaXMuc3R5bGUudGV4dExpbmVIZWlnaHQpXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gYFxuPGRpdiBhcmlhLWxhYmVsPVwiJHthcmlhTGFiZWx9XCIgc3R5bGU9XCIke3RvQ3NzVGV4dChkaXZTdHlsZSl9XCIgdGFiaW5kZXg9XCIwXCI+XG4gIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiR7dGhpcy5zdW1zXy50ZXh0fTwvc3Bhbj5cbjwvZGl2PlxuYDtcclxuICAgIH1cclxuICAgIGdldEltYWdlRWxlbWVudEh0bWwoKSB7XHJcbiAgICAgICAgLy8gTk9URTogdmFsdWVzIG11c3QgYmUgc3BlY2lmaWVkIGluIHB4IHVuaXRzXHJcbiAgICAgICAgY29uc3QgYnAgPSAodGhpcy5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gfHwgXCIwIDBcIikuc3BsaXQoXCIgXCIpO1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZUggPSBwYXJzZUludChicFswXS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKSwgMTApO1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZVYgPSBwYXJzZUludChicFsxXS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKSwgMTApO1xyXG4gICAgICAgIGxldCBkaW1lbnNpb25zID0ge307XHJcbiAgICAgICAgaWYgKHRoaXMuY2x1c3Rlcl8uZ2V0TWFya2VyQ2x1c3RlcmVyKCkuZ2V0RW5hYmxlUmV0aW5hSWNvbnMoKSkge1xyXG4gICAgICAgICAgICBkaW1lbnNpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGNvZXJjZVBpeGVscyh0aGlzLnN0eWxlLndpZHRoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogY29lcmNlUGl4ZWxzKHRoaXMuc3R5bGUuaGVpZ2h0KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgW1kxLCBYMSwgWTIsIFgyXSA9IFtcclxuICAgICAgICAgICAgICAgIC0xICogc3ByaXRlVixcclxuICAgICAgICAgICAgICAgIC0xICogc3ByaXRlSCArIHRoaXMuc3R5bGUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAtMSAqIHNwcml0ZVYgKyB0aGlzLnN0eWxlLmhlaWdodCxcclxuICAgICAgICAgICAgICAgIC0xICogc3ByaXRlSFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBkaW1lbnNpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgY2xpcDogYHJlY3QoJHtZMX1weCwgJHtYMX1weCwgJHtZMn1weCwgJHtYMn1weClgXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNzc1RleHQgPSB0b0Nzc1RleHQoT2JqZWN0LmFzc2lnbih7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHRvcDogY29lcmNlUGl4ZWxzKHNwcml0ZVYpLCBsZWZ0OiBjb2VyY2VQaXhlbHMoc3ByaXRlSCkgfSwgZGltZW5zaW9ucykpO1xyXG4gICAgICAgIHJldHVybiBgPGltZyBhbHQ9XCIke3RoaXMuc3Vtc18udGV4dH1cIiBhcmlhLWhpZGRlbj1cInRydWVcIiBzcmM9XCIke3RoaXMuc3R5bGUudXJsfVwiIHN0eWxlPVwiJHtjc3NUZXh0fVwiLz5gO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBpY29uIHN0eWxlcyB0byB0aGUgYXBwcm9wcmlhdGUgZWxlbWVudCBpbiB0aGUgc3R5bGVzIGFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqIEBwYXJhbSBzdW1zIFRoZSBpY29uIGxhYmVsIHRleHQgYW5kIHN0eWxlcyBpbmRleC5cclxuICAgICAqL1xyXG4gICAgdXNlU3R5bGUoc3Vtcykge1xyXG4gICAgICAgIHRoaXMuc3Vtc18gPSBzdW1zO1xyXG4gICAgICAgIGxldCBpbmRleCA9IE1hdGgubWF4KDAsIHN1bXMuaW5kZXggLSAxKTtcclxuICAgICAgICBpbmRleCA9IE1hdGgubWluKHRoaXMuc3R5bGVzXy5sZW5ndGggLSAxLCBpbmRleCk7XHJcbiAgICAgICAgdGhpcy5zdHlsZSA9IHRoaXMuc3R5bGVzX1tpbmRleF07XHJcbiAgICAgICAgdGhpcy5hbmNob3JUZXh0XyA9IHRoaXMuc3R5bGUuYW5jaG9yVGV4dCB8fCBbMCwgMF07XHJcbiAgICAgICAgdGhpcy5hbmNob3JJY29uXyA9IHRoaXMuc3R5bGUuYW5jaG9ySWNvbiB8fCBbXHJcbiAgICAgICAgICAgIE1hdGguZmxvb3IodGhpcy5zdHlsZS5oZWlnaHQgLyAyKSxcclxuICAgICAgICAgICAgTWF0aC5mbG9vcih0aGlzLnN0eWxlLndpZHRoIC8gMilcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lXyA9XHJcbiAgICAgICAgICAgIHRoaXMuY2x1c3Rlcl8uZ2V0TWFya2VyQ2x1c3RlcmVyKCkuZ2V0Q2x1c3RlckNsYXNzKCkgK1xyXG4gICAgICAgICAgICAgICAgXCIgXCIgK1xyXG4gICAgICAgICAgICAgICAgKHRoaXMuc3R5bGUuY2xhc3NOYW1lIHx8IFwiY2x1c3Rlci1cIiArIGluZGV4KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9zaXRpb24gYXQgd2hpY2ggdG8gY2VudGVyIHRoZSBpY29uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjZW50ZXIgVGhlIGxhdGxuZyB0byBzZXQgYXMgdGhlIGNlbnRlci5cclxuICAgICAqL1xyXG4gICAgc2V0Q2VudGVyKGNlbnRlcikge1xyXG4gICAgICAgIHRoaXMuY2VudGVyXyA9IGNlbnRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgYGNzc1RleHRgIHN0eWxlIHBhcmFtZXRlciBiYXNlZCBvbiB0aGUgcG9zaXRpb24gb2YgdGhlIGljb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvcyBUaGUgcG9zaXRpb24gb2YgdGhlIGljb24uXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBDU1Mgc3R5bGUgdGV4dC5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlQ3NzXyhwb3MpIHtcclxuICAgICAgICByZXR1cm4gdG9Dc3NUZXh0KHtcclxuICAgICAgICAgICAgXCJ6LWluZGV4XCI6IGAke3RoaXMuY2x1c3Rlcl8uZ2V0TWFya2VyQ2x1c3RlcmVyKCkuZ2V0WkluZGV4KCl9YCxcclxuICAgICAgICAgICAgdG9wOiBjb2VyY2VQaXhlbHMocG9zLnkpLFxyXG4gICAgICAgICAgICBsZWZ0OiBjb2VyY2VQaXhlbHMocG9zLngpLFxyXG4gICAgICAgICAgICB3aWR0aDogY29lcmNlUGl4ZWxzKHRoaXMuc3R5bGUud2lkdGgpLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGNvZXJjZVBpeGVscyh0aGlzLnN0eWxlLmhlaWdodCksXHJcbiAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgIFwiLXdlYmtpdC11c2VyLXNlbGVjdFwiOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgXCIta2h0bWwtdXNlci1zZWxlY3RcIjogXCJub25lXCIsXHJcbiAgICAgICAgICAgIFwiLW1vei11c2VyLXNlbGVjdFwiOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgXCItby11c2VyLXNlbGVjdFwiOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgXCJ1c2VyLXNlbGVjdFwiOiBcIm5vbmVcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBhdCB3aGljaCB0byBwbGFjZSB0aGUgRElWIGRlcGVuZGluZyBvbiB0aGUgbGF0bG5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXRsbmcgVGhlIHBvc2l0aW9uIGluIGxhdGxuZy5cclxuICAgICAqIEByZXR1cm4gVGhlIHBvc2l0aW9uIGluIHBpeGVscy5cclxuICAgICAqL1xyXG4gICAgZ2V0UG9zRnJvbUxhdExuZ18obGF0bG5nKSB7XHJcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXRQcm9qZWN0aW9uKCkuZnJvbUxhdExuZ1RvRGl2UGl4ZWwobGF0bG5nKTtcclxuICAgICAgICBwb3MueCA9IE1hdGguZmxvb3IocG9zLnggLSB0aGlzLmFuY2hvckljb25fWzFdKTtcclxuICAgICAgICBwb3MueSA9IE1hdGguZmxvb3IocG9zLnkgLSB0aGlzLmFuY2hvckljb25fWzBdKTtcclxuICAgICAgICByZXR1cm4gcG9zO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHNpbmdsZSBjbHVzdGVyIHRoYXQgbWFuYWdlcyBhIGdyb3VwIG9mIHByb3hpbWF0ZSBtYXJrZXJzLlxyXG4gKiAgVXNlZCBpbnRlcm5hbGx5LCBkbyBub3QgY2FsbCB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxyXG4gKi9cclxuY2xhc3MgQ2x1c3RlciB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFya2VyQ2x1c3RlcmVyXyBUaGUgYE1hcmtlckNsdXN0ZXJlcmAgb2JqZWN0IHdpdGggd2hpY2ggdGhpc1xyXG4gICAgICogIGNsdXN0ZXIgaXMgYXNzb2NpYXRlZC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobWFya2VyQ2x1c3RlcmVyXykge1xyXG4gICAgICAgIHRoaXMubWFya2VyQ2x1c3RlcmVyXyA9IG1hcmtlckNsdXN0ZXJlcl87XHJcbiAgICAgICAgdGhpcy5tYXBfID0gdGhpcy5tYXJrZXJDbHVzdGVyZXJfLmdldE1hcCgpO1xyXG4gICAgICAgIHRoaXMubWluQ2x1c3RlclNpemVfID0gdGhpcy5tYXJrZXJDbHVzdGVyZXJfLmdldE1pbmltdW1DbHVzdGVyU2l6ZSgpO1xyXG4gICAgICAgIHRoaXMuYXZlcmFnZUNlbnRlcl8gPSB0aGlzLm1hcmtlckNsdXN0ZXJlcl8uZ2V0QXZlcmFnZUNlbnRlcigpO1xyXG4gICAgICAgIHRoaXMubWFya2Vyc18gPSBbXTsgLy8gVE9ETzogdHlwZTtcclxuICAgICAgICB0aGlzLmNlbnRlcl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYm91bmRzXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jbHVzdGVySWNvbl8gPSBuZXcgQ2x1c3Rlckljb24odGhpcywgdGhpcy5tYXJrZXJDbHVzdGVyZXJfLmdldFN0eWxlcygpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIG1hcmtlcnMgbWFuYWdlZCBieSB0aGUgY2x1c3Rlci4gWW91IGNhbiBjYWxsIHRoaXMgZnJvbVxyXG4gICAgICogYSBgY2xpY2tgLCBgbW91c2VvdmVyYCwgb3IgYG1vdXNlb3V0YCBldmVudCBoYW5kbGVyIGZvciB0aGUgYE1hcmtlckNsdXN0ZXJlcmAgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gVGhlIG51bWJlciBvZiBtYXJrZXJzIGluIHRoZSBjbHVzdGVyLlxyXG4gICAgICovXHJcbiAgICBnZXRTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtlcnNfLmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgbWFya2VycyBtYW5hZ2VkIGJ5IHRoZSBjbHVzdGVyLiBZb3UgY2FuIGNhbGwgdGhpcyBmcm9tXHJcbiAgICAgKiBhIGBjbGlja2AsIGBtb3VzZW92ZXJgLCBvciBgbW91c2VvdXRgIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgTWFya2VyQ2x1c3RlcmVyYCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBUaGUgYXJyYXkgb2YgbWFya2VycyBpbiB0aGUgY2x1c3Rlci5cclxuICAgICAqL1xyXG4gICAgZ2V0TWFya2VycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXJzXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBjbHVzdGVyLiBZb3UgY2FuIGNhbGwgdGhpcyBmcm9tXHJcbiAgICAgKiBhIGBjbGlja2AsIGBtb3VzZW92ZXJgLCBvciBgbW91c2VvdXRgIGV2ZW50IGhhbmRsZXJcclxuICAgICAqIGZvciB0aGUgYE1hcmtlckNsdXN0ZXJlcmAgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gVGhlIGNlbnRlciBvZiB0aGUgY2x1c3Rlci5cclxuICAgICAqL1xyXG4gICAgZ2V0Q2VudGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlcl87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1hcCB3aXRoIHdoaWNoIHRoZSBjbHVzdGVyIGlzIGFzc29jaWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBUaGUgbWFwLlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBnZXRNYXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYE1hcmtlckNsdXN0ZXJlcmAgb2JqZWN0IHdpdGggd2hpY2ggdGhlIGNsdXN0ZXIgaXMgYXNzb2NpYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBhc3NvY2lhdGVkIG1hcmtlciBjbHVzdGVyZXIuXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGdldE1hcmtlckNsdXN0ZXJlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXJDbHVzdGVyZXJfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIGNsdXN0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB0aGUgY2x1c3RlciBib3VuZHMuXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGdldEJvdW5kcygpIHtcclxuICAgICAgICBjb25zdCBib3VuZHMgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKHRoaXMuY2VudGVyXywgdGhpcy5jZW50ZXJfKTtcclxuICAgICAgICBjb25zdCBtYXJrZXJzID0gdGhpcy5nZXRNYXJrZXJzKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJvdW5kcy5leHRlbmQobWFya2Vyc1tpXS5nZXRQb3NpdGlvbigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgY2x1c3RlciBmcm9tIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICByZW1vdmUoKSB7XHJcbiAgICAgICAgdGhpcy5jbHVzdGVySWNvbl8uc2V0TWFwKG51bGwpO1xyXG4gICAgICAgIHRoaXMubWFya2Vyc18gPSBbXTtcclxuICAgICAgICBkZWxldGUgdGhpcy5tYXJrZXJzXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG1hcmtlciB0byB0aGUgY2x1c3Rlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIG1hcmtlciB3YXMgYWRkZWQuXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGFkZE1hcmtlcihtYXJrZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5pc01hcmtlckFscmVhZHlBZGRlZF8obWFya2VyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5jZW50ZXJfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2VudGVyXyA9IG1hcmtlci5nZXRQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kc18oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmF2ZXJhZ2VDZW50ZXJfKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsID0gdGhpcy5tYXJrZXJzXy5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGF0ID0gKHRoaXMuY2VudGVyXy5sYXQoKSAqIChsIC0gMSkgKyBtYXJrZXIuZ2V0UG9zaXRpb24oKS5sYXQoKSkgLyBsO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbG5nID0gKHRoaXMuY2VudGVyXy5sbmcoKSAqIChsIC0gMSkgKyBtYXJrZXIuZ2V0UG9zaXRpb24oKS5sbmcoKSkgLyBsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jZW50ZXJfID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhsYXQsIGxuZyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kc18oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrZXIuaXNBZGRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5tYXJrZXJzXy5wdXNoKG1hcmtlcik7XHJcbiAgICAgICAgY29uc3QgbUNvdW50ID0gdGhpcy5tYXJrZXJzXy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbXogPSB0aGlzLm1hcmtlckNsdXN0ZXJlcl8uZ2V0TWF4Wm9vbSgpO1xyXG4gICAgICAgIGlmIChteiAhPT0gbnVsbCAmJiB0aGlzLm1hcF8uZ2V0Wm9vbSgpID4gbXopIHtcclxuICAgICAgICAgICAgLy8gWm9vbWVkIGluIHBhc3QgbWF4IHpvb20sIHNvIHNob3cgdGhlIG1hcmtlci5cclxuICAgICAgICAgICAgaWYgKG1hcmtlci5nZXRNYXAoKSAhPT0gdGhpcy5tYXBfKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuc2V0TWFwKHRoaXMubWFwXyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobUNvdW50IDwgdGhpcy5taW5DbHVzdGVyU2l6ZV8pIHtcclxuICAgICAgICAgICAgLy8gTWluIGNsdXN0ZXIgc2l6ZSBub3QgcmVhY2hlZCBzbyBzaG93IHRoZSBtYXJrZXIuXHJcbiAgICAgICAgICAgIGlmIChtYXJrZXIuZ2V0TWFwKCkgIT09IHRoaXMubWFwXykge1xyXG4gICAgICAgICAgICAgICAgbWFya2VyLnNldE1hcCh0aGlzLm1hcF8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1Db3VudCA9PT0gdGhpcy5taW5DbHVzdGVyU2l6ZV8pIHtcclxuICAgICAgICAgICAgLy8gSGlkZSB0aGUgbWFya2VycyB0aGF0IHdlcmUgc2hvd2luZy5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJzX1tpXS5zZXRNYXAobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1hcmtlci5zZXRNYXAobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgbWFya2VyIGxpZXMgd2l0aGluIHRoZSBjbHVzdGVyJ3MgYm91bmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXJrZXIgVGhlIG1hcmtlciB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgbWFya2VyIGxpZXMgaW4gdGhlIGJvdW5kcy5cclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgaXNNYXJrZXJJbkNsdXN0ZXJCb3VuZHMobWFya2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzXy5jb250YWlucyhtYXJrZXIuZ2V0UG9zaXRpb24oKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGV4dGVuZGVkIGJvdW5kcyBvZiB0aGUgY2x1c3RlciB3aXRoIHRoZSBncmlkLlxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVCb3VuZHNfKCkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHModGhpcy5jZW50ZXJfLCB0aGlzLmNlbnRlcl8pO1xyXG4gICAgICAgIHRoaXMuYm91bmRzXyA9IHRoaXMubWFya2VyQ2x1c3RlcmVyXy5nZXRFeHRlbmRlZEJvdW5kcyhib3VuZHMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBjbHVzdGVyIGljb24uXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUljb24oKSB7XHJcbiAgICAgICAgY29uc3QgbUNvdW50ID0gdGhpcy5tYXJrZXJzXy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbXogPSB0aGlzLm1hcmtlckNsdXN0ZXJlcl8uZ2V0TWF4Wm9vbSgpO1xyXG4gICAgICAgIGlmIChteiAhPT0gbnVsbCAmJiB0aGlzLm1hcF8uZ2V0Wm9vbSgpID4gbXopIHtcclxuICAgICAgICAgICAgdGhpcy5jbHVzdGVySWNvbl8uaGlkZSgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtQ291bnQgPCB0aGlzLm1pbkNsdXN0ZXJTaXplXykge1xyXG4gICAgICAgICAgICAvLyBNaW4gY2x1c3RlciBzaXplIG5vdCB5ZXQgcmVhY2hlZC5cclxuICAgICAgICAgICAgdGhpcy5jbHVzdGVySWNvbl8uaGlkZSgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG51bVN0eWxlcyA9IHRoaXMubWFya2VyQ2x1c3RlcmVyXy5nZXRTdHlsZXMoKS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3Qgc3VtcyA9IHRoaXMubWFya2VyQ2x1c3RlcmVyXy5nZXRDYWxjdWxhdG9yKCkodGhpcy5tYXJrZXJzXywgbnVtU3R5bGVzKTtcclxuICAgICAgICB0aGlzLmNsdXN0ZXJJY29uXy5zZXRDZW50ZXIodGhpcy5jZW50ZXJfKTtcclxuICAgICAgICB0aGlzLmNsdXN0ZXJJY29uXy51c2VTdHlsZShzdW1zKTtcclxuICAgICAgICB0aGlzLmNsdXN0ZXJJY29uXy5zaG93KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgaWYgYSBtYXJrZXIgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGUgY2x1c3Rlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIG1hcmtlciBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkLlxyXG4gICAgICovXHJcbiAgICBpc01hcmtlckFscmVhZHlBZGRlZF8obWFya2VyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWFya2Vyc18uaW5kZXhPZikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXJzXy5pbmRleE9mKG1hcmtlcikgIT09IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyID09PSB0aGlzLm1hcmtlcnNfW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY29uc3QgZ2V0T3B0aW9uID0gKG9wdGlvbnMsIHByb3AsIGRlZikgPT4ge1xyXG4gICAgaWYgKG9wdGlvbnNbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zW3Byb3BdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZjtcclxuICAgIH1cclxufTtcclxuY2xhc3MgTWFya2VyQ2x1c3RlcmVyIGV4dGVuZHMgT3ZlcmxheVZpZXdTYWZlIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIE1hcmtlckNsdXN0ZXJlciBvYmplY3Qgd2l0aCB0aGUgb3B0aW9ucyBzcGVjaWZpZWQgaW4ge0BsaW5rIE1hcmtlckNsdXN0ZXJlck9wdGlvbnN9LlxyXG4gICAgICogQHBhcmFtIG1hcCBUaGUgR29vZ2xlIG1hcCB0byBhdHRhY2ggdG8uXHJcbiAgICAgKiBAcGFyYW0gbWFya2VycyBUaGUgbWFya2VycyB0byBiZSBhZGRlZCB0byB0aGUgY2x1c3Rlci5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25hbCBwYXJhbWV0ZXJzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtYXAsIG1hcmtlcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMubWFya2Vyc18gPSBbXTtcclxuICAgICAgICB0aGlzLmNsdXN0ZXJzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlTWFwXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZWFkeV8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFyaWFMYWJlbEZuID0gdGhpcy5vcHRpb25zLmFyaWFMYWJlbEZuIHx8ICgoKSA9PiBcIlwiKTtcclxuICAgICAgICB0aGlzLnpJbmRleF8gPSB0aGlzLm9wdGlvbnMuekluZGV4IHx8IGdvb2dsZS5tYXBzLk1hcmtlci5NQVhfWklOREVYICsgMTtcclxuICAgICAgICB0aGlzLmdyaWRTaXplXyA9IHRoaXMub3B0aW9ucy5ncmlkU2l6ZSB8fCA2MDtcclxuICAgICAgICB0aGlzLm1pbkNsdXN0ZXJTaXplXyA9IHRoaXMub3B0aW9ucy5taW5pbXVtQ2x1c3RlclNpemUgfHwgMjtcclxuICAgICAgICB0aGlzLm1heFpvb21fID0gdGhpcy5vcHRpb25zLm1heFpvb20gfHwgbnVsbDtcclxuICAgICAgICB0aGlzLnN0eWxlc18gPSB0aGlzLm9wdGlvbnMuc3R5bGVzIHx8IFtdO1xyXG4gICAgICAgIHRoaXMudGl0bGVfID0gdGhpcy5vcHRpb25zLnRpdGxlIHx8IFwiXCI7XHJcbiAgICAgICAgdGhpcy56b29tT25DbGlja18gPSBnZXRPcHRpb24odGhpcy5vcHRpb25zLCBcInpvb21PbkNsaWNrXCIsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuYXZlcmFnZUNlbnRlcl8gPSBnZXRPcHRpb24odGhpcy5vcHRpb25zLCBcImF2ZXJhZ2VDZW50ZXJcIiwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuaWdub3JlSGlkZGVuXyA9IGdldE9wdGlvbih0aGlzLm9wdGlvbnMsIFwiaWdub3JlSGlkZGVuXCIsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLmVuYWJsZVJldGluYUljb25zXyA9IGdldE9wdGlvbih0aGlzLm9wdGlvbnMsIFwiZW5hYmxlUmV0aW5hSWNvbnNcIiwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VQYXRoXyA9IHRoaXMub3B0aW9ucy5pbWFnZVBhdGggfHwgTWFya2VyQ2x1c3RlcmVyLklNQUdFX1BBVEg7XHJcbiAgICAgICAgdGhpcy5pbWFnZUV4dGVuc2lvbl8gPSB0aGlzLm9wdGlvbnMuaW1hZ2VFeHRlbnNpb24gfHwgTWFya2VyQ2x1c3RlcmVyLklNQUdFX0VYVEVOU0lPTjtcclxuICAgICAgICB0aGlzLmltYWdlU2l6ZXNfID0gdGhpcy5vcHRpb25zLmltYWdlU2l6ZXMgfHwgTWFya2VyQ2x1c3RlcmVyLklNQUdFX1NJWkVTO1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRvcl8gPSB0aGlzLm9wdGlvbnMuY2FsY3VsYXRvciB8fCBNYXJrZXJDbHVzdGVyZXIuQ0FMQ1VMQVRPUjtcclxuICAgICAgICB0aGlzLmJhdGNoU2l6ZV8gPSB0aGlzLm9wdGlvbnMuYmF0Y2hTaXplIHx8IE1hcmtlckNsdXN0ZXJlci5CQVRDSF9TSVpFO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hTaXplSUVfID0gdGhpcy5vcHRpb25zLmJhdGNoU2l6ZUlFIHx8IE1hcmtlckNsdXN0ZXJlci5CQVRDSF9TSVpFX0lFO1xyXG4gICAgICAgIHRoaXMuY2x1c3RlckNsYXNzXyA9IHRoaXMub3B0aW9ucy5jbHVzdGVyQ2xhc3MgfHwgXCJjbHVzdGVyXCI7XHJcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwibXNpZVwiKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gVHJ5IHRvIGF2b2lkIElFIHRpbWVvdXQgd2hlbiBwcm9jZXNzaW5nIGEgaHVnZSBudW1iZXIgb2YgbWFya2VyczpcclxuICAgICAgICAgICAgdGhpcy5iYXRjaFNpemVfID0gdGhpcy5iYXRjaFNpemVJRV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZXNfKCk7XHJcbiAgICAgICAgdGhpcy5hZGRNYXJrZXJzKG1hcmtlcnMsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuc2V0TWFwKG1hcCk7IC8vIE5vdGU6IHRoaXMgY2F1c2VzIG9uQWRkIHRvIGJlIGNhbGxlZFxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgb25BZGQgaW50ZXJmYWNlIG1ldGhvZC5cclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgb25BZGQoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVNYXBfID0gdGhpcy5nZXRNYXAoKTtcclxuICAgICAgICB0aGlzLnJlYWR5XyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XHJcbiAgICAgICAgdGhpcy5wcmV2Wm9vbV8gPSB0aGlzLmdldE1hcCgpLmdldFpvb20oKTtcclxuICAgICAgICAvLyBBZGQgdGhlIG1hcCBldmVudCBsaXN0ZW5lcnNcclxuICAgICAgICB0aGlzLmxpc3RlbmVyc18gPSBbXHJcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZ2V0TWFwKCksIFwiem9vbV9jaGFuZ2VkXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgLy8gRml4IGZvciBidWcgIzQwN1xyXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lcyBtYXAgdHlwZSBhbmQgcHJldmVudHMgaWxsZWdhbCB6b29tIGxldmVsc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWluWm9vbSA9IG1hcC5taW5ab29tIHx8IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhab29tID0gTWF0aC5taW4obWFwLm1heFpvb20gfHwgMTAwLCBtYXAubWFwVHlwZXNbbWFwLmdldE1hcFR5cGVJZCgpXS5tYXhab29tKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHpvb20gPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLmdldE1hcCgpLmdldFpvb20oKSwgbWluWm9vbSksIG1heFpvb20pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldlpvb21fICE9IHpvb20pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZab29tXyA9IHpvb207XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldFZpZXdwb3J0XyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcih0aGlzLmdldE1hcCgpLCBcImlkbGVcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWRyYXdfKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIG9uUmVtb3ZlIGludGVyZmFjZSBtZXRob2QuXHJcbiAgICAgKiBSZW1vdmVzIG1hcCBldmVudCBsaXN0ZW5lcnMgYW5kIGFsbCBjbHVzdGVyIGljb25zIGZyb20gdGhlIERPTS5cclxuICAgICAqIEFsbCBtYW5hZ2VkIG1hcmtlcnMgYXJlIGFsc28gcHV0IGJhY2sgb24gdGhlIG1hcC5cclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgb25SZW1vdmUoKSB7XHJcbiAgICAgICAgLy8gUHV0IGFsbCB0aGUgbWFuYWdlZCBtYXJrZXJzIGJhY2sgb24gdGhlIG1hcDpcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFya2Vyc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFya2Vyc19baV0uZ2V0TWFwKCkgIT09IHRoaXMuYWN0aXZlTWFwXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJzX1tpXS5zZXRNYXAodGhpcy5hY3RpdmVNYXBfKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgYWxsIGNsdXN0ZXJzOlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jbHVzdGVyc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jbHVzdGVyc19baV0ucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2x1c3RlcnNfID0gW107XHJcbiAgICAgICAgLy8gUmVtb3ZlIG1hcCBldmVudCBsaXN0ZW5lcnM6XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxpc3RlbmVyc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5saXN0ZW5lcnNfW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNfID0gW107XHJcbiAgICAgICAgdGhpcy5hY3RpdmVNYXBfID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlYWR5XyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgZHJhdyBpbnRlcmZhY2UgbWV0aG9kLlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBkcmF3KCkgeyB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgdGhlIHN0eWxlcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHNldHVwU3R5bGVzXygpIHtcclxuICAgICAgICBpZiAodGhpcy5zdHlsZXNfLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW1hZ2VTaXplc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuaW1hZ2VTaXplc19baV07XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzXy5wdXNoKE1hcmtlckNsdXN0ZXJlci53aXRoRGVmYXVsdFN0eWxlKHtcclxuICAgICAgICAgICAgICAgIHVybDogdGhpcy5pbWFnZVBhdGhfICsgKGkgKyAxKSArIFwiLlwiICsgdGhpcy5pbWFnZUV4dGVuc2lvbl8sXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNpemUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogc2l6ZVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgRml0cyB0aGUgbWFwIHRvIHRoZSBib3VuZHMgb2YgdGhlIG1hcmtlcnMgbWFuYWdlZCBieSB0aGUgY2x1c3RlcmVyLlxyXG4gICAgICovXHJcbiAgICBmaXRNYXBUb01hcmtlcnMoKSB7XHJcbiAgICAgICAgY29uc3QgbWFya2VycyA9IHRoaXMuZ2V0TWFya2VycygpO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gTWFyY2ggMywgMjAxODogQnVnIGZpeCAtLSBob25vciB0aGUgaWdub3JlSGlkZGVuIHByb3BlcnR5XHJcbiAgICAgICAgICAgIGlmIChtYXJrZXJzW2ldLmdldFZpc2libGUoKSB8fCAhdGhpcy5nZXRJZ25vcmVIaWRkZW4oKSkge1xyXG4gICAgICAgICAgICAgICAgYm91bmRzLmV4dGVuZChtYXJrZXJzW2ldLmdldFBvc2l0aW9uKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2V0TWFwKCkuZml0Qm91bmRzKGJvdW5kcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBgZ3JpZFNpemVgIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gVGhlIGdyaWQgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0R3JpZFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZFNpemVfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYGdyaWRTaXplYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZ3JpZFNpemUgVGhlIGdyaWQgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgc2V0R3JpZFNpemUoZ3JpZFNpemUpIHtcclxuICAgICAgICB0aGlzLmdyaWRTaXplXyA9IGdyaWRTaXplO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgYG1pbmltdW1DbHVzdGVyU2l6ZWAgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBUaGUgbWluaW11bSBjbHVzdGVyIHNpemUuXHJcbiAgICAgKi9cclxuICAgIGdldE1pbmltdW1DbHVzdGVyU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW5DbHVzdGVyU2l6ZV87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBgbWluaW11bUNsdXN0ZXJTaXplYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWluaW11bUNsdXN0ZXJTaXplIFRoZSBtaW5pbXVtIGNsdXN0ZXIgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgc2V0TWluaW11bUNsdXN0ZXJTaXplKG1pbmltdW1DbHVzdGVyU2l6ZSkge1xyXG4gICAgICAgIHRoaXMubWluQ2x1c3RlclNpemVfID0gbWluaW11bUNsdXN0ZXJTaXplO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGBtYXhab29tYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiAgQHJldHVybiBUaGUgbWF4aW11bSB6b29tIGxldmVsLlxyXG4gICAgICovXHJcbiAgICBnZXRNYXhab29tKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1heFpvb21fO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBtYXhab29tYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiAgQHBhcmFtIG1heFpvb20gVGhlIG1heGltdW0gem9vbSBsZXZlbC5cclxuICAgICAqL1xyXG4gICAgc2V0TWF4Wm9vbShtYXhab29tKSB7XHJcbiAgICAgICAgdGhpcy5tYXhab29tXyA9IG1heFpvb207XHJcbiAgICB9XHJcbiAgICBnZXRaSW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuekluZGV4XztcclxuICAgIH1cclxuICAgIHNldFpJbmRleCh6SW5kZXgpIHtcclxuICAgICAgICB0aGlzLnpJbmRleF8gPSB6SW5kZXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgYHN0eWxlc2AgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogIEByZXR1cm4gVGhlIGFycmF5IG9mIHN0eWxlcyBkZWZpbmluZyB0aGUgY2x1c3RlciBtYXJrZXJzIHRvIGJlIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIGdldFN0eWxlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZXNfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBzdHlsZXNgIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqICBAcGFyYW0gc3R5bGVzIFRoZSBhcnJheSBvZiBzdHlsZXMgdG8gdXNlLlxyXG4gICAgICovXHJcbiAgICBzZXRTdHlsZXMoc3R5bGVzKSB7XHJcbiAgICAgICAgdGhpcy5zdHlsZXNfID0gc3R5bGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgYHRpdGxlYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBjb250ZW50IG9mIHRoZSB0aXRsZSB0ZXh0LlxyXG4gICAgICovXHJcbiAgICBnZXRUaXRsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aXRsZV87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYHRpdGxlYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiAgQHBhcmFtIHRpdGxlIFRoZSB2YWx1ZSBvZiB0aGUgdGl0bGUgcHJvcGVydHkuXHJcbiAgICAgKi9cclxuICAgIHNldFRpdGxlKHRpdGxlKSB7XHJcbiAgICAgICAgdGhpcy50aXRsZV8gPSB0aXRsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGB6b29tT25DbGlja2AgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBUcnVlIGlmIHpvb21PbkNsaWNrIHByb3BlcnR5IGlzIHNldC5cclxuICAgICAqL1xyXG4gICAgZ2V0Wm9vbU9uQ2xpY2soKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuem9vbU9uQ2xpY2tfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGB6b29tT25DbGlja2AgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogIEBwYXJhbSB6b29tT25DbGljayBUaGUgdmFsdWUgb2YgdGhlIHpvb21PbkNsaWNrIHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBzZXRab29tT25DbGljayh6b29tT25DbGljaykge1xyXG4gICAgICAgIHRoaXMuem9vbU9uQ2xpY2tfID0gem9vbU9uQ2xpY2s7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBgYXZlcmFnZUNlbnRlcmAgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBUcnVlIGlmIGF2ZXJhZ2VDZW50ZXIgcHJvcGVydHkgaXMgc2V0LlxyXG4gICAgICovXHJcbiAgICBnZXRBdmVyYWdlQ2VudGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF2ZXJhZ2VDZW50ZXJfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBhdmVyYWdlQ2VudGVyYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiAgQHBhcmFtIGF2ZXJhZ2VDZW50ZXIgVGhlIHZhbHVlIG9mIHRoZSBhdmVyYWdlQ2VudGVyIHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBzZXRBdmVyYWdlQ2VudGVyKGF2ZXJhZ2VDZW50ZXIpIHtcclxuICAgICAgICB0aGlzLmF2ZXJhZ2VDZW50ZXJfID0gYXZlcmFnZUNlbnRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGBpZ25vcmVIaWRkZW5gIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gVHJ1ZSBpZiBpZ25vcmVIaWRkZW4gcHJvcGVydHkgaXMgc2V0LlxyXG4gICAgICovXHJcbiAgICBnZXRJZ25vcmVIaWRkZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWdub3JlSGlkZGVuXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaWdub3JlSGlkZGVuYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiAgQHBhcmFtIGlnbm9yZUhpZGRlbiBUaGUgdmFsdWUgb2YgdGhlIGlnbm9yZUhpZGRlbiBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgc2V0SWdub3JlSGlkZGVuKGlnbm9yZUhpZGRlbikge1xyXG4gICAgICAgIHRoaXMuaWdub3JlSGlkZGVuXyA9IGlnbm9yZUhpZGRlbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGBlbmFibGVSZXRpbmFJY29uc2AgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBUcnVlIGlmIGVuYWJsZVJldGluYUljb25zIHByb3BlcnR5IGlzIHNldC5cclxuICAgICAqL1xyXG4gICAgZ2V0RW5hYmxlUmV0aW5hSWNvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlUmV0aW5hSWNvbnNfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBlbmFibGVSZXRpbmFJY29uc2AgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogIEBwYXJhbSBlbmFibGVSZXRpbmFJY29ucyBUaGUgdmFsdWUgb2YgdGhlIGVuYWJsZVJldGluYUljb25zIHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBzZXRFbmFibGVSZXRpbmFJY29ucyhlbmFibGVSZXRpbmFJY29ucykge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlUmV0aW5hSWNvbnNfID0gZW5hYmxlUmV0aW5hSWNvbnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBgaW1hZ2VFeHRlbnNpb25gIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gVGhlIHZhbHVlIG9mIHRoZSBpbWFnZUV4dGVuc2lvbiBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgZ2V0SW1hZ2VFeHRlbnNpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VFeHRlbnNpb25fO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBpbWFnZUV4dGVuc2lvbmAgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogIEBwYXJhbSBpbWFnZUV4dGVuc2lvbiBUaGUgdmFsdWUgb2YgdGhlIGltYWdlRXh0ZW5zaW9uIHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBzZXRJbWFnZUV4dGVuc2lvbihpbWFnZUV4dGVuc2lvbikge1xyXG4gICAgICAgIHRoaXMuaW1hZ2VFeHRlbnNpb25fID0gaW1hZ2VFeHRlbnNpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBgaW1hZ2VQYXRoYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIFRoZSB2YWx1ZSBvZiB0aGUgaW1hZ2VQYXRoIHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBnZXRJbWFnZVBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VQYXRoXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaW1hZ2VQYXRoYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiAgQHBhcmFtIGltYWdlUGF0aCBUaGUgdmFsdWUgb2YgdGhlIGltYWdlUGF0aCBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgc2V0SW1hZ2VQYXRoKGltYWdlUGF0aCkge1xyXG4gICAgICAgIHRoaXMuaW1hZ2VQYXRoXyA9IGltYWdlUGF0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGBpbWFnZVNpemVzYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIFRoZSB2YWx1ZSBvZiB0aGUgaW1hZ2VTaXplcyBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgZ2V0SW1hZ2VTaXplcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZVNpemVzXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaW1hZ2VTaXplc2AgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogIEBwYXJhbSBpbWFnZVNpemVzIFRoZSB2YWx1ZSBvZiB0aGUgaW1hZ2VTaXplcyBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgc2V0SW1hZ2VTaXplcyhpbWFnZVNpemVzKSB7XHJcbiAgICAgICAgdGhpcy5pbWFnZVNpemVzXyA9IGltYWdlU2l6ZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBgY2FsY3VsYXRvcmAgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGNhbGN1bGF0b3IgcHJvcGVydHkuXHJcbiAgICAgKi9cclxuICAgIGdldENhbGN1bGF0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRvcl87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBgY2FsY3VsYXRvcmAgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGN1bGF0b3IgVGhlIHZhbHVlIG9mIHRoZSBjYWxjdWxhdG9yIHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBzZXRDYWxjdWxhdG9yKGNhbGN1bGF0b3IpIHtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0b3JfID0gY2FsY3VsYXRvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGBiYXRjaFNpemVJRWAgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGJhdGNoU2l6ZUlFIHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBnZXRCYXRjaFNpemVJRSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iYXRjaFNpemVJRV87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBgYmF0Y2hTaXplSUVgIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqICBAcGFyYW0gYmF0Y2hTaXplSUUgVGhlIHZhbHVlIG9mIHRoZSBiYXRjaFNpemVJRSBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgc2V0QmF0Y2hTaXplSUUoYmF0Y2hTaXplSUUpIHtcclxuICAgICAgICB0aGlzLmJhdGNoU2l6ZUlFXyA9IGJhdGNoU2l6ZUlFO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgYGNsdXN0ZXJDbGFzc2AgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGNsdXN0ZXJDbGFzcyBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgZ2V0Q2x1c3RlckNsYXNzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsdXN0ZXJDbGFzc187XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBgY2x1c3RlckNsYXNzYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiAgQHBhcmFtIGNsdXN0ZXJDbGFzcyBUaGUgdmFsdWUgb2YgdGhlIGNsdXN0ZXJDbGFzcyBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgc2V0Q2x1c3RlckNsYXNzKGNsdXN0ZXJDbGFzcykge1xyXG4gICAgICAgIHRoaXMuY2x1c3RlckNsYXNzXyA9IGNsdXN0ZXJDbGFzcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIGFycmF5IG9mIG1hcmtlcnMgbWFuYWdlZCBieSB0aGUgY2x1c3RlcmVyLlxyXG4gICAgICpcclxuICAgICAqICBAcmV0dXJuIFRoZSBhcnJheSBvZiBtYXJrZXJzIG1hbmFnZWQgYnkgdGhlIGNsdXN0ZXJlci5cclxuICAgICAqL1xyXG4gICAgZ2V0TWFya2VycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXJzXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFJldHVybnMgdGhlIG51bWJlciBvZiBtYXJrZXJzIG1hbmFnZWQgYnkgdGhlIGNsdXN0ZXJlci5cclxuICAgICAqXHJcbiAgICAgKiAgQHJldHVybiBUaGUgbnVtYmVyIG9mIG1hcmtlcnMuXHJcbiAgICAgKi9cclxuICAgIGdldFRvdGFsTWFya2VycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXJzXy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYXJyYXkgb2YgY2x1c3RlcnMgZm9ybWVkIGJ5IHRoZSBjbHVzdGVyZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBUaGUgYXJyYXkgb2YgY2x1c3RlcnMgZm9ybWVkIGJ5IHRoZSBjbHVzdGVyZXIuXHJcbiAgICAgKi9cclxuICAgIGdldENsdXN0ZXJzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsdXN0ZXJzXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNsdXN0ZXJzIGZvcm1lZCBieSB0aGUgY2x1c3RlcmVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gVGhlIG51bWJlciBvZiBjbHVzdGVycyBmb3JtZWQgYnkgdGhlIGNsdXN0ZXJlci5cclxuICAgICAqL1xyXG4gICAgZ2V0VG90YWxDbHVzdGVycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbHVzdGVyc18ubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbWFya2VyIHRvIHRoZSBjbHVzdGVyZXIuIFRoZSBjbHVzdGVycyBhcmUgcmVkcmF3biB1bmxlc3NcclxuICAgICAqICBgbm9kcmF3YCBpcyBzZXQgdG8gYHRydWVgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXJrZXIgVGhlIG1hcmtlciB0byBhZGQuXHJcbiAgICAgKiBAcGFyYW0gbm9kcmF3IFNldCB0byBgdHJ1ZWAgdG8gcHJldmVudCByZWRyYXdpbmcuXHJcbiAgICAgKi9cclxuICAgIGFkZE1hcmtlcihtYXJrZXIsIG5vZHJhdykge1xyXG4gICAgICAgIHRoaXMucHVzaE1hcmtlclRvXyhtYXJrZXIpO1xyXG4gICAgICAgIGlmICghbm9kcmF3KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVkcmF3XygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBhcnJheSBvZiBtYXJrZXJzIHRvIHRoZSBjbHVzdGVyZXIuIFRoZSBjbHVzdGVycyBhcmUgcmVkcmF3biB1bmxlc3NcclxuICAgICAqICBgbm9kcmF3YCBpcyBzZXQgdG8gYHRydWVgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXJrZXJzIFRoZSBtYXJrZXJzIHRvIGFkZC5cclxuICAgICAqIEBwYXJhbSBub2RyYXcgU2V0IHRvIGB0cnVlYCB0byBwcmV2ZW50IHJlZHJhd2luZy5cclxuICAgICAqL1xyXG4gICAgYWRkTWFya2VycyhtYXJrZXJzLCBub2RyYXcpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXJrZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFya2Vycywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoTWFya2VyVG9fKG1hcmtlcnNba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFub2RyYXcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWRyYXdfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQdXNoZXMgYSBtYXJrZXIgdG8gdGhlIGNsdXN0ZXJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gYWRkLlxyXG4gICAgICovXHJcbiAgICBwdXNoTWFya2VyVG9fKG1hcmtlcikge1xyXG4gICAgICAgIC8vIElmIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlIGFkZCBhIGxpc3RlbmVyIHNvIHdlIGNhbiB1cGRhdGUgdGhlIGNsdXN0ZXJzIG9uIHRoZSBkcmFnZW5kOlxyXG4gICAgICAgIGlmIChtYXJrZXIuZ2V0RHJhZ2dhYmxlKCkpIHtcclxuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCBcImRyYWdlbmRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLmlzQWRkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcmtlci5pc0FkZGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tYXJrZXJzXy5wdXNoKG1hcmtlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBtYXJrZXIgZnJvbSB0aGUgY2x1c3Rlci4gIFRoZSBjbHVzdGVycyBhcmUgcmVkcmF3biB1bmxlc3NcclxuICAgICAqICBgbm9kcmF3YCBpcyBzZXQgdG8gYHRydWVgLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGVcclxuICAgICAqICBtYXJrZXIgd2FzIHJlbW92ZWQgZnJvbSB0aGUgY2x1c3RlcmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXJrZXIgVGhlIG1hcmtlciB0byByZW1vdmUuXHJcbiAgICAgKiBAcGFyYW0gbm9kcmF3IFNldCB0byBgdHJ1ZWAgdG8gcHJldmVudCByZWRyYXdpbmcuXHJcbiAgICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIG1hcmtlciB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBjbHVzdGVyZXIuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZU1hcmtlcihtYXJrZXIsIG5vZHJhdykge1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWQgPSB0aGlzLnJlbW92ZU1hcmtlcl8obWFya2VyKTtcclxuICAgICAgICBpZiAoIW5vZHJhdyAmJiByZW1vdmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbiBhcnJheSBvZiBtYXJrZXJzIGZyb20gdGhlIGNsdXN0ZXIuIFRoZSBjbHVzdGVycyBhcmUgcmVkcmF3biB1bmxlc3NcclxuICAgICAqICBgbm9kcmF3YCBpcyBzZXQgdG8gYHRydWVgLiBSZXR1cm5zIGB0cnVlYCBpZiBtYXJrZXJzIHdlcmUgcmVtb3ZlZCBmcm9tIHRoZSBjbHVzdGVyZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcmtlcnMgVGhlIG1hcmtlcnMgdG8gcmVtb3ZlLlxyXG4gICAgICogQHBhcmFtIG5vZHJhdyBTZXQgdG8gYHRydWVgIHRvIHByZXZlbnQgcmVkcmF3aW5nLlxyXG4gICAgICogQHJldHVybiBUcnVlIGlmIG1hcmtlcnMgd2VyZSByZW1vdmVkIGZyb20gdGhlIGNsdXN0ZXJlci5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlTWFya2VycyhtYXJrZXJzLCBub2RyYXcpIHtcclxuICAgICAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCByID0gdGhpcy5yZW1vdmVNYXJrZXJfKG1hcmtlcnNbaV0pO1xyXG4gICAgICAgICAgICByZW1vdmVkID0gcmVtb3ZlZCB8fCByO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5vZHJhdyAmJiByZW1vdmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIG1hcmtlciBhbmQgcmV0dXJucyB0cnVlIGlmIHJlbW92ZWQsIGZhbHNlIGlmIG5vdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gcmVtb3ZlXHJcbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhlIG1hcmtlciB3YXMgcmVtb3ZlZCBvciBub3RcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlTWFya2VyXyhtYXJrZXIpIHtcclxuICAgICAgICBsZXQgaW5kZXggPSAtMTtcclxuICAgICAgICBpZiAodGhpcy5tYXJrZXJzXy5pbmRleE9mKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5tYXJrZXJzXy5pbmRleE9mKG1hcmtlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFya2Vyc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IHRoaXMubWFya2Vyc19baV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBNYXJrZXIgaXMgbm90IGluIG91ciBsaXN0IG9mIG1hcmtlcnMsIHNvIGRvIG5vdGhpbmc6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFya2VyLnNldE1hcChudWxsKTtcclxuICAgICAgICB0aGlzLm1hcmtlcnNfLnNwbGljZShpbmRleCwgMSk7IC8vIFJlbW92ZSB0aGUgbWFya2VyIGZyb20gdGhlIGxpc3Qgb2YgbWFuYWdlZCBtYXJrZXJzXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGNsdXN0ZXJzIGFuZCBtYXJrZXJzIGZyb20gdGhlIG1hcCBhbmQgYWxzbyByZW1vdmVzIGFsbCBtYXJrZXJzXHJcbiAgICAgKiAgbWFuYWdlZCBieSB0aGUgY2x1c3RlcmVyLlxyXG4gICAgICovXHJcbiAgICBjbGVhck1hcmtlcnMoKSB7XHJcbiAgICAgICAgdGhpcy5yZXNldFZpZXdwb3J0Xyh0cnVlKTtcclxuICAgICAgICB0aGlzLm1hcmtlcnNfID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlY2FsY3VsYXRlcyBhbmQgcmVkcmF3cyBhbGwgdGhlIG1hcmtlciBjbHVzdGVycyBmcm9tIHNjcmF0Y2guXHJcbiAgICAgKiAgQ2FsbCB0aGlzIGFmdGVyIGNoYW5naW5nIGFueSBwcm9wZXJ0aWVzLlxyXG4gICAgICovXHJcbiAgICByZXBhaW50KCkge1xyXG4gICAgICAgIGNvbnN0IG9sZENsdXN0ZXJzID0gdGhpcy5jbHVzdGVyc18uc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmNsdXN0ZXJzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMucmVzZXRWaWV3cG9ydF8oZmFsc2UpO1xyXG4gICAgICAgIHRoaXMucmVkcmF3XygpO1xyXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgb2xkIGNsdXN0ZXJzLlxyXG4gICAgICAgIC8vIERvIGl0IGluIGEgdGltZW91dCB0byBwcmV2ZW50IGJsaW5raW5nIGVmZmVjdC5cclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbGRDbHVzdGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgb2xkQ2x1c3RlcnNbaV0ucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBib3VuZHMgZXh0ZW5kZWQgYnkgdGhlIGdyaWQgc2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYm91bmRzIFRoZSBib3VuZHMgdG8gZXh0ZW5kLlxyXG4gICAgICogQHJldHVybiBUaGUgZXh0ZW5kZWQgYm91bmRzLlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBnZXRFeHRlbmRlZEJvdW5kcyhib3VuZHMpIHtcclxuICAgICAgICBjb25zdCBwcm9qZWN0aW9uID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XHJcbiAgICAgICAgLy8gVHVybiB0aGUgYm91bmRzIGludG8gbGF0bG5nLlxyXG4gICAgICAgIGNvbnN0IHRyID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhib3VuZHMuZ2V0Tm9ydGhFYXN0KCkubGF0KCksIGJvdW5kcy5nZXROb3J0aEVhc3QoKS5sbmcoKSk7XHJcbiAgICAgICAgY29uc3QgYmwgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGJvdW5kcy5nZXRTb3V0aFdlc3QoKS5sYXQoKSwgYm91bmRzLmdldFNvdXRoV2VzdCgpLmxuZygpKTtcclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBwb2ludHMgdG8gcGl4ZWxzIGFuZCB0aGUgZXh0ZW5kIG91dCBieSB0aGUgZ3JpZCBzaXplLlxyXG4gICAgICAgIGNvbnN0IHRyUGl4ID0gcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9EaXZQaXhlbCh0cik7XHJcbiAgICAgICAgdHJQaXgueCArPSB0aGlzLmdyaWRTaXplXztcclxuICAgICAgICB0clBpeC55IC09IHRoaXMuZ3JpZFNpemVfO1xyXG4gICAgICAgIGNvbnN0IGJsUGl4ID0gcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9EaXZQaXhlbChibCk7XHJcbiAgICAgICAgYmxQaXgueCAtPSB0aGlzLmdyaWRTaXplXztcclxuICAgICAgICBibFBpeC55ICs9IHRoaXMuZ3JpZFNpemVfO1xyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHBpeGVsIHBvaW50cyBiYWNrIHRvIExhdExuZ1xyXG4gICAgICAgIGNvbnN0IG5lID0gcHJvamVjdGlvbi5mcm9tRGl2UGl4ZWxUb0xhdExuZyh0clBpeCk7XHJcbiAgICAgICAgY29uc3Qgc3cgPSBwcm9qZWN0aW9uLmZyb21EaXZQaXhlbFRvTGF0TG5nKGJsUGl4KTtcclxuICAgICAgICAvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBuZXcgYm91bmRzLlxyXG4gICAgICAgIGJvdW5kcy5leHRlbmQobmUpO1xyXG4gICAgICAgIGJvdW5kcy5leHRlbmQoc3cpO1xyXG4gICAgICAgIHJldHVybiBib3VuZHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZHJhd3MgYWxsIHRoZSBjbHVzdGVycy5cclxuICAgICAqL1xyXG4gICAgcmVkcmF3XygpIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZUNsdXN0ZXJzXygwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgY2x1c3RlcnMgZnJvbSB0aGUgbWFwLiBUaGUgbWFya2VycyBhcmUgYWxzbyByZW1vdmVkIGZyb20gdGhlIG1hcFxyXG4gICAgICogIGlmIGBoaWRlYCBpcyBzZXQgdG8gYHRydWVgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBoaWRlIFNldCB0byBgdHJ1ZWAgdG8gYWxzbyByZW1vdmUgdGhlIG1hcmtlcnMgZnJvbSB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICByZXNldFZpZXdwb3J0XyhoaWRlKSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB0aGUgY2x1c3RlcnNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2x1c3RlcnNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2x1c3RlcnNfW2ldLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsdXN0ZXJzXyA9IFtdO1xyXG4gICAgICAgIC8vIFJlc2V0IHRoZSBtYXJrZXJzIHRvIG5vdCBiZSBhZGRlZCBhbmQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBtYXAuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IHRoaXMubWFya2Vyc19baV07XHJcbiAgICAgICAgICAgIG1hcmtlci5pc0FkZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChoaWRlKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuc2V0TWFwKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBsYXRsbmcgbG9jYXRpb25zIGluIGttLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwMSBUaGUgZmlyc3QgbGF0IGxuZyBwb2ludC5cclxuICAgICAqIEBwYXJhbSBwMiBUaGUgc2Vjb25kIGxhdCBsbmcgcG9pbnQuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzIGluIGttLlxyXG4gICAgICogQGxpbmsgaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9sYXRsb25nLmh0bWxcclxuICAgICAqL1xyXG4gICAgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzXyhwMSwgcDIpIHtcclxuICAgICAgICBjb25zdCBSID0gNjM3MTsgLy8gUmFkaXVzIG9mIHRoZSBFYXJ0aCBpbiBrbVxyXG4gICAgICAgIGNvbnN0IGRMYXQgPSAoKHAyLmxhdCgpIC0gcDEubGF0KCkpICogTWF0aC5QSSkgLyAxODA7XHJcbiAgICAgICAgY29uc3QgZExvbiA9ICgocDIubG5nKCkgLSBwMS5sbmcoKSkgKiBNYXRoLlBJKSAvIDE4MDtcclxuICAgICAgICBjb25zdCBhID0gTWF0aC5zaW4oZExhdCAvIDIpICogTWF0aC5zaW4oZExhdCAvIDIpICtcclxuICAgICAgICAgICAgTWF0aC5jb3MoKHAxLmxhdCgpICogTWF0aC5QSSkgLyAxODApICpcclxuICAgICAgICAgICAgICAgIE1hdGguY29zKChwMi5sYXQoKSAqIE1hdGguUEkpIC8gMTgwKSAqXHJcbiAgICAgICAgICAgICAgICBNYXRoLnNpbihkTG9uIC8gMikgKlxyXG4gICAgICAgICAgICAgICAgTWF0aC5zaW4oZExvbiAvIDIpO1xyXG4gICAgICAgIGNvbnN0IGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xyXG4gICAgICAgIHJldHVybiBSICogYztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIG1hcmtlciBpcyBjb250YWluZWQgaW4gYSBib3VuZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcmtlciBUaGUgbWFya2VyIHRvIGNoZWNrLlxyXG4gICAgICogQHBhcmFtIGJvdW5kcyBUaGUgYm91bmRzIHRvIGNoZWNrIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIG1hcmtlciBpcyBpbiB0aGUgYm91bmRzLlxyXG4gICAgICovXHJcbiAgICBpc01hcmtlckluQm91bmRzXyhtYXJrZXIsIGJvdW5kcykge1xyXG4gICAgICAgIHJldHVybiBib3VuZHMuY29udGFpbnMobWFya2VyLmdldFBvc2l0aW9uKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbWFya2VyIHRvIGEgY2x1c3Rlciwgb3IgY3JlYXRlcyBhIG5ldyBjbHVzdGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXJrZXIgVGhlIG1hcmtlciB0byBhZGQuXHJcbiAgICAgKi9cclxuICAgIGFkZFRvQ2xvc2VzdENsdXN0ZXJfKG1hcmtlcikge1xyXG4gICAgICAgIGxldCBkaXN0YW5jZSA9IDQwMDAwOyAvLyBTb21lIGxhcmdlIG51bWJlclxyXG4gICAgICAgIGxldCBjbHVzdGVyVG9BZGRUbyA9IG51bGw7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNsdXN0ZXJzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjbHVzdGVyID0gdGhpcy5jbHVzdGVyc19baV07XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IGNsdXN0ZXIuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgIGlmIChjZW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLmRpc3RhbmNlQmV0d2VlblBvaW50c18oY2VudGVyLCBtYXJrZXIuZ2V0UG9zaXRpb24oKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZCA8IGRpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJUb0FkZFRvID0gY2x1c3RlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2x1c3RlclRvQWRkVG8gJiYgY2x1c3RlclRvQWRkVG8uaXNNYXJrZXJJbkNsdXN0ZXJCb3VuZHMobWFya2VyKSkge1xyXG4gICAgICAgICAgICBjbHVzdGVyVG9BZGRUby5hZGRNYXJrZXIobWFya2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXIgPSBuZXcgQ2x1c3Rlcih0aGlzKTtcclxuICAgICAgICAgICAgY2x1c3Rlci5hZGRNYXJrZXIobWFya2VyKTtcclxuICAgICAgICAgICAgdGhpcy5jbHVzdGVyc18ucHVzaChjbHVzdGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIGNsdXN0ZXJzLiBUaGlzIGlzIGRvbmUgaW4gYmF0Y2hlcyB0byBhdm9pZCB0aW1lb3V0IGVycm9yc1xyXG4gICAgICogIGluIHNvbWUgYnJvd3NlcnMgd2hlbiB0aGVyZSBpcyBhIGh1Z2UgbnVtYmVyIG9mIG1hcmtlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlGaXJzdCBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IG1hcmtlciBpbiB0aGUgYmF0Y2ggb2ZcclxuICAgICAqICBtYXJrZXJzIHRvIGJlIGFkZGVkIHRvIGNsdXN0ZXJzLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVDbHVzdGVyc18oaUZpcnN0KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlYWR5Xykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbmNlbCBwcmV2aW91cyBiYXRjaCBwcm9jZXNzaW5nIGlmIHdlJ3JlIHdvcmtpbmcgb24gdGhlIGZpcnN0IGJhdGNoOlxyXG4gICAgICAgIGlmIChpRmlyc3QgPT09IDApIHtcclxuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCBcImNsdXN0ZXJpbmdiZWdpblwiLCB0aGlzKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRpbWVyUmVmU3RhdGljICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lclJlZlN0YXRpYyk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50aW1lclJlZlN0YXRpYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHZXQgb3VyIGN1cnJlbnQgbWFwIHZpZXcgYm91bmRzLlxyXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBib3VuZHMgb2JqZWN0IHNvIHdlIGRvbid0IGFmZmVjdCB0aGUgbWFwLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gU2VlIENvbW1lbnRzIDkgJiAxMSBvbiBJc3N1ZSAzNjUxIHJlbGF0aW5nIHRvIHRoaXMgd29ya2Fyb3VuZCBmb3IgYSBHb29nbGUgTWFwcyBidWc6XHJcbiAgICAgICAgbGV0IG1hcEJvdW5kcztcclxuICAgICAgICBpZiAodGhpcy5nZXRNYXAoKS5nZXRab29tKCkgPiAzKSB7XHJcbiAgICAgICAgICAgIG1hcEJvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHModGhpcy5nZXRNYXAoKS5nZXRCb3VuZHMoKS5nZXRTb3V0aFdlc3QoKSwgdGhpcy5nZXRNYXAoKS5nZXRCb3VuZHMoKS5nZXROb3J0aEVhc3QoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtYXBCb3VuZHMgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoODUuMDIwNzA3NzE3NDM0NzIsIC0xNzguNDgzODg0MzQzNzUpLCBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKC04NS4wODEzNjQ0NDM4NDU0NCwgMTc4LjAwMDQ4ODY1NjI1KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0RXh0ZW5kZWRCb3VuZHMobWFwQm91bmRzKTtcclxuICAgICAgICBjb25zdCBpTGFzdCA9IE1hdGgubWluKGlGaXJzdCArIHRoaXMuYmF0Y2hTaXplXywgdGhpcy5tYXJrZXJzXy5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBpRmlyc3Q7IGkgPCBpTGFzdDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IHRoaXMubWFya2Vyc19baV07XHJcbiAgICAgICAgICAgIGlmICghbWFya2VyLmlzQWRkZWQgJiYgdGhpcy5pc01hcmtlckluQm91bmRzXyhtYXJrZXIsIGJvdW5kcykpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pZ25vcmVIaWRkZW5fIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuaWdub3JlSGlkZGVuXyAmJiBtYXJrZXIuZ2V0VmlzaWJsZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVG9DbG9zZXN0Q2x1c3Rlcl8obWFya2VyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaUxhc3QgPCB0aGlzLm1hcmtlcnNfLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVyUmVmU3RhdGljID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVDbHVzdGVyc18oaUxhc3QpO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRpbWVyUmVmU3RhdGljO1xyXG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMsIFwiY2x1c3RlcmluZ2VuZFwiLCB0aGlzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNsdXN0ZXJzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbHVzdGVyc19baV0udXBkYXRlSWNvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgdGhlIGxhYmVsIHRleHQgYW5kIHN0eWxlXHJcbiAgICAgKiBmb3IgYSBjbHVzdGVyIGljb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcmtlcnMgVGhlIGFycmF5IG9mIG1hcmtlcnMgcmVwcmVzZW50ZWQgYnkgdGhlIGNsdXN0ZXIuXHJcbiAgICAgKiBAcGFyYW0gbnVtU3R5bGVzIFRoZSBudW1iZXIgb2YgbWFya2VyIHN0eWxlcyBhdmFpbGFibGUuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBpbmZvcm1hdGlvbiByZXNvdXJjZSBmb3IgdGhlIGNsdXN0ZXIuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBDQUxDVUxBVE9SKG1hcmtlcnMsIG51bVN0eWxlcykge1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSBtYXJrZXJzLmxlbmd0aDtcclxuICAgICAgICBsZXQgZHYgPSBjb3VudDtcclxuICAgICAgICB3aGlsZSAoZHYgIT09IDApIHtcclxuICAgICAgICAgICAgZHYgPSBNYXRoLmZsb29yKGR2IC8gMTApO1xyXG4gICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmRleCA9IE1hdGgubWluKGluZGV4LCBudW1TdHlsZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRleHQ6IGNvdW50LnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgICAgICAgdGl0bGU6IFwiXCJcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgZGVmYXVsdCBzdHlsZXMgYXVnbWVudGVkIHdpdGggdXNlciBwYXNzZWQgdmFsdWVzLlxyXG4gICAgICogVXNlZnVsIHdoZW4geW91IHdhbnQgdG8gb3ZlcnJpZGUgc29tZSBkZWZhdWx0IHZhbHVlcyBidXQga2VlcCB1bnRvdWNoZWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3ZlcnJpZGVzIG92ZXJyaWRlIGRlZmF1bHQgdmFsdWVzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB3aXRoRGVmYXVsdFN0eWxlKG92ZXJyaWRlcykge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgdGV4dENvbG9yOiBcImJsYWNrXCIsIHRleHRTaXplOiAxMSwgdGV4dERlY29yYXRpb246IFwibm9uZVwiLCB0ZXh0TGluZUhlaWdodDogb3ZlcnJpZGVzLmhlaWdodCwgZm9udFdlaWdodDogXCJib2xkXCIsIGZvbnRTdHlsZTogXCJub3JtYWxcIiwgZm9udEZhbWlseTogXCJBcmlhbCxzYW5zLXNlcmlmXCIsIGJhY2tncm91bmRQb3NpdGlvbjogXCIwIDBcIiB9LCBvdmVycmlkZXMpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgbnVtYmVyIG9mIG1hcmtlcnMgdG8gcHJvY2VzcyBpbiBvbmUgYmF0Y2guXHJcbiAqL1xyXG5NYXJrZXJDbHVzdGVyZXIuQkFUQ0hfU0laRSA9IDIwMDA7XHJcbi8qKlxyXG4gKiBUaGUgbnVtYmVyIG9mIG1hcmtlcnMgdG8gcHJvY2VzcyBpbiBvbmUgYmF0Y2ggKElFIG9ubHkpLlxyXG4gKi9cclxuTWFya2VyQ2x1c3RlcmVyLkJBVENIX1NJWkVfSUUgPSA1MDA7XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCByb290IG5hbWUgZm9yIHRoZSBtYXJrZXIgY2x1c3RlciBpbWFnZXMuXHJcbiAqL1xyXG5NYXJrZXJDbHVzdGVyZXIuSU1BR0VfUEFUSCA9IFwiLi4vaW1hZ2VzL21cIjtcclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGV4dGVuc2lvbiBuYW1lIGZvciB0aGUgbWFya2VyIGNsdXN0ZXIgaW1hZ2VzLlxyXG4gKi9cclxuTWFya2VyQ2x1c3RlcmVyLklNQUdFX0VYVEVOU0lPTiA9IFwicG5nXCI7XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBhcnJheSBvZiBzaXplcyBmb3IgdGhlIG1hcmtlciBjbHVzdGVyIGltYWdlcy5cclxuICovXHJcbk1hcmtlckNsdXN0ZXJlci5JTUFHRV9TSVpFUyA9IFs1MywgNTYsIDY2LCA3OCwgOTBdO1xuXG4vKipcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgTWFya2VyQ2x1c3RlcmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFya2VyY2x1c3RlcmVycGx1cy5lc20uanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n')}}]);